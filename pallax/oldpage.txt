"use client"
import React, { useState, useRef, useEffect, useCallback } from 'react';
import { gsap } from 'gsap';
import { SplitText } from 'gsap/SplitText';
import Image from "next/image";
import styles from './Pallax.module.css';
import lifeidesignsvg from '../../assets/images/lifeidesignsvg.svg';
import eyelid from '../../../public/eye_lid.svg';
import SlideFlippingWords from '../../components/Flipping_words/SlideFlippingWords';
import GameEcosystem from '../../components/GameEcosystem';
import { Slide1Reviews, Slide2Hero, Slide3Demo, Slide6HeroFlipped, Slide11HeroFinal, Slide16DDIntroduction, Slide19FAQ } from './components';

// Register GSAP plugins
if (typeof window !== 'undefined') {
  gsap.registerPlugin(SplitText);
}

// 22 individual words for each slide
const slideWords = [
  "GAME LAUNCH    ",
  "GAME PASS      ",
  "GAME REVIEWS   ",
  "GAME MOAT      ",
  "GAME AIM       ",
  "GAME VOID      ",
  "GAME CROWD     ",
  "GAME PLOT      ",
  "GAME OUTCOME   ",
  "GAME FLOW      ",
  "GAME PAUSE     ",
  "GAME QUEST     ",
  "GAME EXPERIENCE",
  "GAME SERIES    ",
  "GAME ECOSYSTEM ",
  "GAME HOST      ",
  "GAME GANG      ",
  "GAME WORD      ",
  "GAME FAQ       ",
  "GAME LINKS     ",
  "GAME PASS      ",
  "GAME CONTACT   "
];

// 22 dummy text descriptions for each slide
const dummyTexts = [
  "Play Beyond Zero Sum",
  "Win Your Game Pass.",
  "Voices from the Void.",
  "Beyond Self-Help. Into Self-Play.",
  "Visualize with intention",
  "Disappear to Discover.",
  "For Those Who Dare.",
  "Shift Between \"They\" and \"I\".",
  "Gain Some. Lose Some.",
  "Sequence of Play",
  "Breath Before Becoming",
  "Architecture of Ascension.",
  "Body of the Game.",
  "Evolution, Not Sequel.",
  "World Beyond Play.",
  "I orchestrate, You play.",
  "Game is a gang sport.",
  "What OGs Spoke",
  "When Riddle Runs Out.",
  "Press Portal",
  "This Is Your Move.",
  "Player enters the room"
];

// Member data for Section 2 (Customer Reviews)
const memberData = [
  {
    name: "Zain Menon",
    description: "Zain Memon is a celebrated game designer. His bestselling board games SHASN and AZADI are played in over 70 countries. His work has won prestigious 'Games For Change' and 'IndieCade' awards."
  },
  {
    name: "Anand Gandhi",
    description: "Anand Gandhi is a visionary filmmaker and game designer. His work explores the intersection of technology, philosophy, and human consciousness, creating immersive experiences that challenge conventional storytelling."
  },
  {
    name: "Sarah Chen",
    description: "Sarah Chen is a cognitive psychologist and game theorist. She specializes in designing experiences that leverage behavioral science to create meaningful personal transformation through play."
  },
  {
    name: "Marcus Rodriguez",
    description: "Marcus Rodriguez is a creative technologist and VR pioneer. His innovative approaches to immersive storytelling have revolutionized how we think about digital experiences and human interaction."
  },
  {
    name: "Elena Petrova",
    description: "Elena Petrova is a narrative designer and world-builder. Her expertise in creating rich, interconnected universes has shaped some of the most compelling game worlds of the past decade."
  },
  {
    name: "David Kim",
    description: "David Kim is a systems designer and strategic consultant. His work focuses on creating scalable frameworks that balance complexity with accessibility in game design."
  },
  {
    name: "Aisha Patel",
    description: "Aisha Patel is a community architect and social impact designer. She specializes in building inclusive spaces where diverse voices can collaborate and create meaningful change."
  },
  {
    name: "James Wilson",
    description: "James Wilson is a data scientist and behavioral analyst. His research-driven approach to game design ensures that every experience is optimized for maximum engagement and impact."
  },
  {
    name: "Maria Santos",
    description: "Maria Santos is a cultural anthropologist and experience designer. Her work bridges ancient wisdom with modern technology, creating games that honor tradition while embracing innovation."
  }
];

// ScrollRevealSection component for slide 7
const ScrollRevealSection = ({ onAllColumnsVisible, currentSection, isScrollEnabled = true }) => {
  const containerRef = useRef(null);
  const [visibleColumns, setVisibleColumns] = useState(isScrollEnabled ? 0 : 3);
  const [skipTransitions, setSkipTransitions] = useState(true); // Start with transitions disabled
  const [isInitialized, setIsInitialized] = useState(false);
  const columnsRef = useRef([]);
  const scrollTimeoutRef = useRef(null);
  const isScrollingRef = useRef(false);

  // Refs for controlling flipping words manually
  const boldArtistFlipRef = useRef(null);
  const valueCreatorFlipRef = useRef(null);
  const creativeEntrepreneurFlipRef = useRef(null);

  // Track which columns have been triggered to prevent re-triggering
  const [triggeredColumns, setTriggeredColumns] = useState(new Set());

  // Initialize component with proper state to prevent flash
  useEffect(() => {
    // Set initial state immediately without transitions
    setSkipTransitions(true);
    setVisibleColumns(isScrollEnabled ? 0 : 3);

    // Enable transitions after a brief delay to prevent flash
    const timer = setTimeout(() => {
      setSkipTransitions(false);
      setIsInitialized(true);
    }, 100);

    return () => clearTimeout(timer);
  }, []);

  // Reset visible columns when isScrollEnabled changes
  useEffect(() => {
    if (!isInitialized) return; // Don't run until initialized

    setSkipTransitions(true); // Disable transitions during state change

    if (!isScrollEnabled) {
      setVisibleColumns(6);
      if (onAllColumnsVisible) {
        onAllColumnsVisible();
      }
    } else {
      setVisibleColumns(0); // Start with no columns when scroll effect is enabled
      // Set initial scroll position to match step 0
      const container = containerRef.current;
      if (container) {
        container.scrollTop = 0; // Step 0 position
      }
    }

    // Re-enable transitions after state change
    setTimeout(() => {
      setSkipTransitions(false);
    }, 50);
  }, [isScrollEnabled, onAllColumnsVisible, isInitialized]);

  // Reset to initial state when entering slide 7 (currentSection === 6)
  useEffect(() => {
    if (!isInitialized) return;

    if (currentSection === 6 && isScrollEnabled) {
      // Reset to initial state when entering slide 7
      setSkipTransitions(true);
      setVisibleColumns(0);
      setTriggeredColumns(new Set()); // Reset triggered columns

      // Set initial scroll position
      const container = containerRef.current;
      if (container) {
        container.scrollTop = 0; // Step 0 position
      }

      // Re-enable transitions after reset
      setTimeout(() => {
        setSkipTransitions(false);
      }, 100);
    }
  }, [currentSection, isScrollEnabled, isInitialized]);

  // Trigger flipping animations when visibleColumns changes (for slide 7)
  useEffect(() => {
    if (isInitialized && visibleColumns >= 1) {
      // Trigger BOLD ARTIST (column 1) when it becomes visible (step 1)
      if (visibleColumns >= 1 && boldArtistFlipRef.current && !triggeredColumns.has(1)) {
        setTimeout(() => {
          boldArtistFlipRef.current.triggerFlip();
          setTriggeredColumns(prev => new Set(prev).add(1));
        }, 200);
      }

      // Trigger VALUE CREATOR (column 2) when it becomes visible (step 2)
      if (visibleColumns >= 2 && valueCreatorFlipRef.current && !triggeredColumns.has(2)) {
        setTimeout(() => {
          valueCreatorFlipRef.current.triggerFlip();
          setTriggeredColumns(prev => new Set(prev).add(2));
        }, 400);
      }

      // Trigger CREATIVE ENTREPRENEUR (column 3) when it becomes visible (step 3)
      if (visibleColumns >= 3 && creativeEntrepreneurFlipRef.current && !triggeredColumns.has(3)) {
        setTimeout(() => {
          creativeEntrepreneurFlipRef.current.triggerFlip();
          setTriggeredColumns(prev => new Set(prev).add(3));
        }, 600);
      }
    }
  }, [visibleColumns, isInitialized, triggeredColumns]);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    // If scroll effect is disabled, don't add wheel listeners
    if (!isScrollEnabled) {
      return;
    }

    let wheelDelta = 0;
    let wheelTimer = null;
    let currentStep = 0; // 0, 1, 2, 3 for each column reveal step (start from 0)

    const smoothScrollToStep = (step, skipAnimation = false) => {
      if (isScrollingRef.current) return;
      isScrollingRef.current = true;

      const scrollHeight = container.scrollHeight;
      const containerHeight = container.clientHeight;
      const maxScroll = scrollHeight - containerHeight;

      // Define precise scroll positions for each step
      const scrollPositions = [
        0,                    // Step 0: No columns visible
        maxScroll * 0.2,      // Step 1: First column
        maxScroll * 0.45,     // Step 2: Second column  
        maxScroll * 0.7,      // Step 3: Third column
        maxScroll             // Step 4: Complete (triggers next slide)
      ];

      const targetScroll = scrollPositions[step] || 0;

      // Update state immediately and skip animation if requested
      if (skipAnimation || step === 0) {
        setSkipTransitions(true);
        container.scrollTop = targetScroll;
        setVisibleColumns(step);
        currentStep = step;
        isScrollingRef.current = false;

        // Re-enable transitions after a brief moment
        setTimeout(() => {
          setSkipTransitions(false);
        }, 50);

        // Notify parent when all columns are visible
        if (step === 3 && onAllColumnsVisible) {
          onAllColumnsVisible();
        }

        return;
      }

      // Smooth scroll animation using requestAnimationFrame
      const startScroll = container.scrollTop;
      const distance = targetScroll - startScroll;
      const duration = 800; // 800ms for smooth animation
      const startTime = performance.now();

      const animateScroll = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Easing function for smooth animation (easeInOutCubic)
        const easeProgress = progress < 0.5
          ? 4 * progress * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 3) / 2;

        container.scrollTop = startScroll + (distance * easeProgress);

        if (progress < 1) {
          requestAnimationFrame(animateScroll);
        } else {
          isScrollingRef.current = false;

          // Update visible columns based on step
          setVisibleColumns(step);
          currentStep = step;

          // Notify parent when all columns are visible
          if (step === 3 && onAllColumnsVisible) {
            onAllColumnsVisible();
          }

          // Auto-advance to next slide when reaching step 4
          if (step >= 4 && currentSection === 6) {
            setTimeout(() => {
              // Double check we're still on slide 7 before advancing
              if (window.gotoNextSlide && currentSection === 6) {
                window.gotoNextSlide();
              }
            }, 300);
          }
        }
      };

      requestAnimationFrame(animateScroll);
    };

    const handleWheel = (e) => {
      e.preventDefault();

      if (isScrollingRef.current) return;

      // Accumulate wheel delta
      wheelDelta += e.deltaY;

      // Clear existing timer
      if (wheelTimer) {
        clearTimeout(wheelTimer);
      }

      // Wait for wheel events to settle
      wheelTimer = setTimeout(() => {
        if (Math.abs(wheelDelta) > 30) { // Lower threshold for more responsive
          if (wheelDelta > 0) {
            // Scroll down - next step
            const nextStep = Math.min(currentStep + 1, 4);
            smoothScrollToStep(nextStep);
          } else {
            // Scroll up - previous step or go to previous slide
            if (currentStep === 0) {
              // At the beginning (step 0), go to previous slide
              if (window.gotoPrevSlide) {
                window.gotoPrevSlide();
              }
            } else {
              const prevStep = Math.max(currentStep - 1, 0);
              smoothScrollToStep(prevStep);
            }
          }
        }
        wheelDelta = 0; // Reset delta
      }, 5); // Very short delay
    };

    container.addEventListener('wheel', handleWheel, { passive: false });

    return () => {
      container.removeEventListener('wheel', handleWheel);
      if (wheelTimer) clearTimeout(wheelTimer);
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);
    };
  }, [onAllColumnsVisible, isScrollEnabled]);

  return (
    <div
      ref={containerRef}
      className={styles.scrollRevealContainer}
      style={{
        height: '100vh',
        overflowY: 'auto',
        overflowX: 'hidden'
      }}
    >
      <div style={{ height: '200vh', position: 'relative' }}>
        <div className={styles.featuresContainer} style={{
          position: 'sticky',
          top: 0,
          height: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center'
        }}>
          {/* Top text - always visible */}
          <div
            className={styles.featuresTopText}
            style={{
              opacity: 1,
              transform: 'translateY(0)',
              marginBottom: '40px',
              textAlign: 'center'
            }}
          >
            <p className={styles.heroParagraph} style={{
              fontFamily: '"satoshi", sans-serif',
              fontSize: '14px',
              fontWeight: '500',
              letterSpacing: '1px',
              color: '#888888'
            }}>
              Together, they form a daring kind,l
              who play with vision, not confined.
            </p>
          </div>

          <div className={styles.threeColumnGrid}>
            <div
              ref={el => columnsRef.current[0] = el}
              className={`${styles.gridColumn} ${!isInitialized ? styles.gridColumnInitial : ''}`}
              style={{
                opacity: visibleColumns >= 1 ? 1 : 0,
                transform: visibleColumns >= 1 ? 'translateX(0)' : 'translateX(100px)',
                transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
              }}
            >
              <div className={styles.columnTitle}>
                <h3 style={{
                  fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                  fontSize: '26px',
                  color: '#00e87b',
                  fontWeight: 'normal',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                  margin: 0
                }}>
                  BOLD ARTIST
                </h3>
              </div>
              <div className={styles.textContent}>
                <p className={styles.heroParagraph} style={{
                  fontFamily: '"satoshi", sans-serif',
                  fontSize: '14px',
                  fontWeight: '500',
                  letterSpacing: '1px',
                  color: '#888888'
                }}>
                  Feels in color, speaks through fire,
                  designs emotion to inspire.
                </p>
              </div>
              <div className={styles.imageContent}>
                <Image
                  src={lifeidesignsvg}
                  width={200}
                  height={200}
                  alt="Life i Design Game"
                  className={styles.heroImageContent}
                />
              </div>
            </div>

            <div
              ref={el => columnsRef.current[1] = el}
              className={`${styles.gridColumn} ${!isInitialized && isScrollEnabled ? styles.gridColumnInitial : ''}`}
              style={{
                opacity: visibleColumns >= 2 ? 1 : 0,
                transform: visibleColumns >= 2 ? 'translateX(0)' : 'translateX(100px)',
                transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
              }}
            >
              <div className={styles.columnTitle}>
                <h3 style={{
                  fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                  fontSize: '26px',
                  color: '#00e87b',
                  fontWeight: 'normal',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                  margin: 0
                }}>
                  VALUE CREATOR
                </h3>
              </div>
              <div className={styles.textContent}>
                <p className={styles.heroParagraph} style={{
                  fontFamily: '"satoshi", sans-serif',
                  fontSize: '14px',
                  fontWeight: '500',
                  letterSpacing: '1px',
                  color: '#888888'
                }}>
                  Finds the pattern in the blur,
                  turns each idea to something sure.
                </p>
              </div>
              <div className={styles.imageContent}>
                <Image
                  src={lifeidesignsvg}
                  width={200}
                  height={200}
                  alt="Life i Design Game"
                  className={styles.heroImageContent}
                />
              </div>
            </div>

            <div
              ref={el => columnsRef.current[2] = el}
              className={`${styles.gridColumn} ${!isInitialized && isScrollEnabled ? styles.gridColumnInitial : ''}`}
              style={{
                opacity: visibleColumns >= 3 ? 1 : 0,
                transform: visibleColumns >= 3 ? 'translateX(0)' : 'translateX(100px)',
                transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.4s'
              }}
            >
              <div className={styles.columnTitle}>
                <h3 style={{
                  fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                  fontSize: '26px',
                  color: '#00e87b',
                  fontWeight: 'normal',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                  margin: 0
                }}>
                  CREATIVE ENTREPRENEUR
                </h3>
              </div>
              <div className={styles.textContent}>
                <p className={styles.heroParagraph} style={{
                  fontFamily: '"satoshi", sans-serif',
                  fontSize: '14px',
                  fontWeight: '500',
                  letterSpacing: '1px',
                  color: '#888888'
                }}>
                  Trades the safe for paths unknown,
                  builds his freedom from his own.
                </p>
              </div>
              <div className={styles.imageContent}>
                <Image
                  src={lifeidesignsvg}
                  width={200}
                  height={200}
                  alt="Life i Design Game"
                  className={styles.heroImageContent}
                />
              </div>
            </div>
          </div>

          {/* Progress Indicator Line */}
          <div className={styles.columnProgressIndicator}>
            <div className={styles.progressLine}>
              <div
                className={styles.progressSegment}
                style={{
                  opacity: visibleColumns >= 1 ? 1 : 0,
                  transform: visibleColumns >= 1 ? 'scale(1)' : 'scale(0)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
                }}
              >
                <div
                  className={`${styles.progressNumber} ${visibleColumns >= 1 ? styles.progressActive : ''}`}
                  style={{
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
                  }}
                >
                </div>
              </div>
              <div
                className={`${styles.progressConnector} ${visibleColumns >= 2 ? styles.progressActive : ''}`}
                style={{
                  opacity: visibleColumns >= 2 ? 1 : 0,
                  transform: visibleColumns >= 2 ? 'scaleX(1)' : 'scaleX(0)',
                  transformOrigin: 'left',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.1s'
                }}
              ></div>
              <div
                className={styles.progressSegment}
                style={{
                  opacity: visibleColumns >= 2 ? 1 : 0,
                  transform: visibleColumns >= 2 ? 'scale(1)' : 'scale(0)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
                }}
              >
                <div
                  className={`${styles.progressNumber} ${visibleColumns >= 2 ? styles.progressActive : ''}`}
                  style={{
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
                  }}
                >
                </div>
              </div>
              <div
                className={`${styles.progressConnector} ${visibleColumns >= 3 ? styles.progressActive : ''}`}
                style={{
                  opacity: visibleColumns >= 3 ? 1 : 0,
                  transform: visibleColumns >= 3 ? 'scaleX(1)' : 'scaleX(0)',
                  transformOrigin: 'left',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.3s'
                }}
              ></div>
              <div
                className={styles.progressSegment}
                style={{
                  opacity: visibleColumns >= 3 ? 1 : 0,
                  transform: visibleColumns >= 3 ? 'scale(1)' : 'scale(0)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.4s'
                }}
              >
                <div
                  className={`${styles.progressNumber} ${visibleColumns >= 3 ? styles.progressActive : ''}`}
                  style={{
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.4s'
                  }}
                >
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

// ScrollRevealSection component for slide 9 (Gains vs Losses)
const ScrollRevealSectionSlide9 = ({ onAllColumnsVisible, currentSection, isScrollEnabled = true }) => {
  const containerRef = useRef(null);
  const [visibleColumns, setVisibleColumns] = useState(isScrollEnabled ? 0 : 5);
  const [skipTransitions, setSkipTransitions] = useState(true);
  const [isInitialized, setIsInitialized] = useState(false);
  const columnsRef = useRef([]);
  const scrollTimeoutRef = useRef(null);
  const isScrollingRef = useRef(false);

  // Refs for controlling flipping words manually
  const youWillGainFlipRef = useRef(null);
  const youWillLoseFlipRef = useRef(null);

  // Track which columns have been triggered to prevent re-triggering
  const [triggeredColumns, setTriggeredColumns] = useState(new Set());

  // Initialize component with proper state to prevent flash
  useEffect(() => {
    setSkipTransitions(true);
    setVisibleColumns(isScrollEnabled ? 0 : 5);

    const timer = setTimeout(() => {
      setSkipTransitions(false);
      setIsInitialized(true);
    }, 100);

    return () => clearTimeout(timer);
  }, []);

  // Reset visible columns when isScrollEnabled changes
  useEffect(() => {
    if (!isInitialized) return; // Don't run until initialized

    setSkipTransitions(true); // Disable transitions during state change
    setTriggeredColumns(new Set()); // Reset triggered columns

    if (!isScrollEnabled) {
      setVisibleColumns(6);
      if (onAllColumnsVisible) {
        onAllColumnsVisible();
      }
    } else {
      setVisibleColumns(0);
      const container = containerRef.current;
      if (container) {
        const scrollHeight = container.scrollHeight;
        const containerHeight = container.clientHeight;
        const maxScroll = scrollHeight - containerHeight;
        container.scrollTop = 0;
      }
    }

    // Re-enable transitions after state change
    setTimeout(() => {
      setSkipTransitions(false);
    }, 50);
  }, [isScrollEnabled, onAllColumnsVisible, isInitialized]);

  // Reset to initial state when entering slide 9 (currentSection === 8)
  useEffect(() => {
    if (!isInitialized) return;

    if (currentSection === 8 && isScrollEnabled) {
      setSkipTransitions(true);
      setVisibleColumns(0);
      setTriggeredColumns(new Set()); // Reset triggered columns

      const container = containerRef.current;
      if (container) {
        const scrollHeight = container.scrollHeight;
        const containerHeight = container.clientHeight;
        const maxScroll = scrollHeight - containerHeight;
        container.scrollTop = 0;
      }

      setTimeout(() => {
        setSkipTransitions(false);
      }, 100);
    }
  }, [currentSection, isScrollEnabled, isInitialized]);

  // Trigger flipping animations when visibleColumns changes (for slide 9)
  useEffect(() => {
    if (isInitialized && visibleColumns >= 1) {
      // Trigger YOU WILL GAIN when gains section becomes visible (step 1)
      if (visibleColumns >= 1 && youWillGainFlipRef.current && !triggeredColumns.has(1)) {
        setTimeout(() => {
          youWillGainFlipRef.current.triggerFlip();
          setTriggeredColumns(prev => new Set(prev).add(1));
        }, 200);
      }

      // Trigger YOU WILL LOSE when losses section becomes visible (step 2)
      if (visibleColumns >= 2 && youWillLoseFlipRef.current && !triggeredColumns.has(2)) {
        setTimeout(() => {
          youWillLoseFlipRef.current.triggerFlip();
          setTriggeredColumns(prev => new Set(prev).add(2));
        }, 400);
      }
    }
  }, [visibleColumns, isInitialized, triggeredColumns]);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    if (!isScrollEnabled) {
      return;
    }

    let wheelDelta = 0;
    let wheelTimer = null;
    let currentStep = 0;

    const smoothScrollToStep = (step, skipAnimation = false) => {
      if (isScrollingRef.current) return;
      isScrollingRef.current = true;

      const scrollHeight = container.scrollHeight;
      const containerHeight = container.clientHeight;
      const maxScroll = scrollHeight - containerHeight;

      const scrollPositions = [
        0,                    // Step 0: Top text + separator line visible
        maxScroll * 0.125,    // Step 1: "YOU WILL GAIN" header appears
        maxScroll * 0.25,     // Step 2: "YOU WILL LOSE" header appears
        maxScroll * 0.375,    // Step 3: First items (both columns)
        maxScroll * 0.5,      // Step 4: Second items (both columns)
        maxScroll * 0.625,    // Step 5: Third items (both columns)
        maxScroll * 0.75,     // Step 6: Fourth items (both columns)
        maxScroll * 0.875,    // Step 7: All content visible
        maxScroll             // Step 8: Complete (triggers next slide)
      ];

      const targetScroll = scrollPositions[step] || 0;

      if (skipAnimation || step === 0) {
        setSkipTransitions(true);
        container.scrollTop = targetScroll;
        setVisibleColumns(step);
        currentStep = step;
        isScrollingRef.current = false;

        setTimeout(() => {
          setSkipTransitions(false);
        }, 50);

        if (step === 7 && onAllColumnsVisible) {
          onAllColumnsVisible();
        }

        return;
      }

      const startScroll = container.scrollTop;
      const distance = targetScroll - startScroll;
      const duration = 800;
      const startTime = performance.now();

      const animateScroll = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        const easeProgress = progress < 0.5
          ? 4 * progress * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 3) / 2;

        container.scrollTop = startScroll + (distance * easeProgress);

        if (progress < 1) {
          requestAnimationFrame(animateScroll);
        } else {
          isScrollingRef.current = false;
          setVisibleColumns(step);
          currentStep = step;

          if (step === 7 && onAllColumnsVisible) {
            onAllColumnsVisible();
          }

          if (step >= 8 && currentSection === 8) {
            setTimeout(() => {
              if (window.gotoNextSlide && currentSection === 8) {
                window.gotoNextSlide();
              }
            }, 300);
          }
        }
      };

      requestAnimationFrame(animateScroll);
    };

    const handleWheel = (e) => {
      e.preventDefault();

      if (isScrollingRef.current) return;

      wheelDelta += e.deltaY;

      if (wheelTimer) {
        clearTimeout(wheelTimer);
      }

      wheelTimer = setTimeout(() => {
        if (Math.abs(wheelDelta) > 30) {
          if (wheelDelta > 0) {
            const nextStep = Math.min(currentStep + 1, 8);
            smoothScrollToStep(nextStep);
          } else {
            if (currentStep === 0) {
              if (window.gotoPrevSlide) {
                window.gotoPrevSlide();
              }
            } else {
              const prevStep = Math.max(currentStep - 1, 0);
              smoothScrollToStep(prevStep);
            }
          }
        }
        wheelDelta = 0;
      }, 5);
    };

    container.addEventListener('wheel', handleWheel, { passive: false });

    return () => {
      container.removeEventListener('wheel', handleWheel);
      if (wheelTimer) {
        clearTimeout(wheelTimer);
      }
    };
  }, [currentSection, isScrollEnabled, onAllColumnsVisible, isInitialized]);

  return (
    <div className={styles.gainsContainer}>
      <div
        ref={containerRef}
        style={{
          position: 'relative',
          top: 0,
          height: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center'
        }}>
        <div
          className={styles.gainsTopText}
          style={{
            opacity: visibleColumns >= 0 ? 1 : 0,
            transform: visibleColumns >= 0 ? 'translateY(0)' : 'translateY(30px)',
            transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease',
            marginBottom: '5px',
            textAlign: 'center'
          }}
        >
          <p className={styles.heroParagraph} style={{
            fontFamily: '"satoshi", sans-serif',
            fontSize: '14px',
            fontWeight: '500',
            letterSpacing: '1px',
            color: '#888888'
          }}>
           In every change, some truth will stay, and what must fall will fade away.
          </p>
        </div>


        <div className={styles.gainsMainContent}>
          <div className={styles.gainsSection}>
            <h3 
              className={styles.sectionTitle}
              style={{
                opacity: visibleColumns >= 1 ? 1 : 0,
                transform: visibleColumns >= 1 ? 'translateY(0)' : 'translateY(30px)',
                transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.1s'
              }}
            >
              <h3 style={{
                fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                fontSize: '26px',
                color: '#00e87b',
                fontWeight: 'normal',
                textTransform: 'uppercase',
                letterSpacing: '1px',
                margin: 0
              }}>
                YOU WILL GAIN
              </h3>
            </h3>
            <div className={`${styles.gainsGrid2x2}`}>
              <div className={styles.cardWrapper}>
              <div
                className={styles.hoverCard}
                style={{
                  opacity: visibleColumns >= 3 ? 1 : 0,
                  transform: visibleColumns >= 3 ? 'translateY(0)' : 'translateY(30px)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
                }}
              >
                <div className={styles.cardContent}>
                    <div className={styles.cardEmoji}>üí™</div>
                    <div className={styles.cardHoverContent}>
                  <p className={styles.cardDescription}>The fuel that frees your flame.</p>
                </div>
              </div>
                </div>
                <h4 
                  className={styles.cardTitleBelow}
                  style={{
                    opacity: visibleColumns >= 3 ? 1 : 0,
                    transform: visibleColumns >= 3 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
                  }}
                >Selfishness</h4>
              </div>
              <div className={styles.cardWrapper}>
              <div
                className={styles.hoverCard}
                style={{
                  opacity: visibleColumns >= 4 ? 1 : 0,
                  transform: visibleColumns >= 4 ? 'translateY(0)' : 'translateY(30px)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.1s'
                }}
              >
                <div className={styles.cardContent}>
                    <div className={styles.cardEmoji}>üëë</div>
                    <div className={styles.cardHoverContent}>
                  <p className={styles.cardDescription}>The crown that bears your name.</p>
                </div>
              </div>
                </div>
                <h4 
                  className={styles.cardTitleBelow}
                  style={{
                    opacity: visibleColumns >= 4 ? 1 : 0,
                    transform: visibleColumns >= 4 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.1s'
                  }}
                >Sovereignty</h4>
              </div>
              <div className={styles.cardWrapper}>
              <div
                className={styles.hoverCard}
                style={{
                  opacity: visibleColumns >= 5 ? 1 : 0,
                  transform: visibleColumns >= 5 ? 'translateY(0)' : 'translateY(30px)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
                }}
              >
                <div className={styles.cardContent}>
                    <div className={styles.cardEmoji}>üî•</div>
                    <div className={styles.cardHoverContent}>
                  <p className={styles.cardDescription}>The hunger that shapes your fire.</p>
                </div>
              </div>
                </div>
                <h4 
                  className={styles.cardTitleBelow}
                  style={{
                    opacity: visibleColumns >= 5 ? 1 : 0,
                    transform: visibleColumns >= 5 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
                  }}
                >Obsession</h4>
              </div>
              <div className={styles.cardWrapper}>
              <div
                className={styles.hoverCard}
                style={{
                  opacity: visibleColumns >= 6 ? 1 : 0,
                  transform: visibleColumns >= 6 ? 'translateY(0)' : 'translateY(30px)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.3s'
                }}
              >
                <div className={styles.cardContent}>
                    <div className={styles.cardEmoji}>üé®</div>
                    <div className={styles.cardHoverContent}>
                  <p className={styles.cardDescription}>The ground where you never tire.</p>
                </div>
                  </div>
                </div>
                <h4 
                  className={styles.cardTitleBelow}
                  style={{
                    opacity: visibleColumns >= 6 ? 1 : 0,
                    transform: visibleColumns >= 6 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.3s'
                  }}
                >Creation</h4>
              </div>
            </div>
          </div>

          <div className={styles.separatorLine}></div>

          <div className={styles.lossesSection}>
            <h3 
              className={styles.sectionTitle}
              style={{
                opacity: visibleColumns >= 2 ? 1 : 0,
                transform: visibleColumns >= 2 ? 'translateY(0)' : 'translateY(30px)',
                transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.1s'
              }}
            >
              <h3 style={{
                fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                fontSize: '26px',
                color: '#00e87b',
                fontWeight: 'normal',
                textTransform: 'uppercase',
                letterSpacing: '1px',
                margin: 0
              }}>
                YOU WILL LOSE
              </h3>
            </h3>
            <div className={`${styles.lossesGrid2x2}`}>
              <div className={styles.cardWrapper}>
              <div
                className={styles.hoverCard}
                style={{
                  opacity: visibleColumns >= 3 ? 1 : 0,
                  transform: visibleColumns >= 3 ? 'translateY(0)' : 'translateY(30px)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
                }}
              >
                <div className={styles.cardContent}>
                    <div className={styles.cardEmoji}>üëè</div>
                    <div className={styles.cardHoverContent}>
                  <p className={styles.cardDescription}>The mirror that bends your view.</p>
                </div>
              </div>
                </div>
                <h4 
                  className={styles.cardTitleBelow}
                  style={{
                    opacity: visibleColumns >= 3 ? 1 : 0,
                    transform: visibleColumns >= 3 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
                  }}
                >Approval</h4>
              </div>
              <div className={styles.cardWrapper}>
              <div
                className={styles.hoverCard}
                style={{
                  opacity: visibleColumns >= 4 ? 1 : 0,
                  transform: visibleColumns >= 4 ? 'translateY(0)' : 'translateY(30px)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.1s'
                }}
              >
                <div className={styles.cardContent}>
                    <div className={styles.cardEmoji}>‚ùì</div>
                    <div className={styles.cardHoverContent}>
                  <p className={styles.cardDescription}>The fog that hides your cue..</p>
                </div>
              </div>
                </div>
                <h4 
                  className={styles.cardTitleBelow}
                  style={{
                    opacity: visibleColumns >= 4 ? 1 : 0,
                    transform: visibleColumns >= 4 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.1s'
                  }}
                >Excuses</h4>
              </div>
              <div className={styles.cardWrapper}>
              <div
                className={styles.hoverCard}
                style={{
                  opacity: visibleColumns >= 5 ? 1 : 0,
                  transform: visibleColumns >= 5 ? 'translateY(0)' : 'translateY(30px)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
                }}
              >
                <div className={styles.cardContent}>
                    <div className={styles.cardEmoji}>üè†</div>
                    <div className={styles.cardHoverContent}>
                  <p className={styles.cardDescription}>The cage you called your peace.</p>
                </div>
              </div>
                </div>
                <h4 
                  className={styles.cardTitleBelow}
                  style={{
                    opacity: visibleColumns >= 5 ? 1 : 0,
                    transform: visibleColumns >= 5 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
                  }}
                >Comfort</h4>
              </div>
              <div className={styles.cardWrapper}>
              <div
                className={styles.hoverCard}
                style={{
                  opacity: visibleColumns >= 6 ? 1 : 0,
                  transform: visibleColumns >= 6 ? 'translateY(0)' : 'translateY(30px)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.3s'
                }}
              >
                <div className={styles.cardContent}>
                    <div className={styles.cardEmoji}>‚è∞</div>
                    <div className={styles.cardHoverContent}>
                  <p className={styles.cardDescription}>The clock that won't release.</p>
                </div>
                  </div>
                </div>
                <h4 
                  className={styles.cardTitleBelow}
                  style={{
                    opacity: visibleColumns >= 6 ? 1 : 0,
                    transform: visibleColumns >= 6 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.3s'
                  }}
                >Fear</h4>
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>
  );
};

// ScrollRevealSection component for slide 10 (Game Flow) - New overlapping cards + images layout
const ScrollRevealSectionSlide10 = ({ onAllColumnsVisible, currentSection, isScrollEnabled = true }) => {
  const containerRef = useRef(null);
  const cardsStackRef = useRef(null);
  const [activeCard, setActiveCard] = useState(0);
  const [isInitialized, setIsInitialized] = useState(false);
  const isScrollingRef = useRef(false);

  const gameFlowCardsData = [
    {
      id: 0,
      title: "Hourly Games",
      subtitle: "Free",
      description: "Small missions that mirror your core,each move reveals a little more.",
      color: "#ff6b6b",
      imageUrl: "https://lidbucketnew.s3.ap-south-1.amazonaws.com/avatar/avatar1.svg"
    },
    {
      id: 1,
      title: "Weekly Games",
      subtitle: "Free",
      description: "A weekend path to shift your scheme,wake-up to design, not just to dream.",
      color: "#4ecdc4",
      imageUrl: "https://lidbucketnew.s3.ap-south-1.amazonaws.com/avatar/avatar2.svg"
    },
    {
      id: 2,
      title: "Quarterly Games",
      subtitle: "Premium",
      description: "Each season you sculpt, rebuild, renew,discipline bends to what is true.",
      color: "#f7b731",
      imageUrl: "https://lidbucketnew.s3.ap-south-1.amazonaws.com/avatar/avatar3.svg"
    },
    {
      id: 3,
      title: "Annual Games",
      subtitle: "Premium",
      description: "One year to play the game divine,you merge with god ‚Äî your own design.",
      color: "#5f27cd",
      imageUrl: "https://lidbucketnew.s3.ap-south-1.amazonaws.com/avatar/avatar4.svg"
    }
  ];

  // Animate cards to show stacking effect
  const animateToCard = useCallback((targetIndex) => {
    setActiveCard(targetIndex);

    // Animate each card based on its relationship to the active card
    const cardWrappers = cardsStackRef.current?.querySelectorAll(`.${styles.gameFlowCardWrapper}`);
    if (!cardWrappers) return;

    cardWrappers.forEach((wrapper, index) => {
      const card = wrapper.querySelector(`.${styles.gameFlowCard}`);
      if (!card) return;

      if (index <= targetIndex) {
        // Cards that should be visible/active - no scaling, keep full size
        const rotationX = index === targetIndex ? 0 : 0; // No rotation for cleaner look
        const yOffset = index * 80 + 100; // Increased offset to show titles and green separator line + center vertically

        wrapper.style.transform = `translateY(${yOffset}px)`;
        card.style.transform = `rotateX(${rotationX}deg) scale(1)`; // Always scale 1
        card.style.opacity = '1';
        card.style.zIndex = index + 1;

        // Add active class to current card
        if (index === targetIndex) {
          card.classList.add(styles.gameFlowCardActive);
        } else {
          card.classList.remove(styles.gameFlowCardActive);
        }
      } else {
        // Cards that should be hidden (slide down)
        const yOffset = window.innerHeight;
        wrapper.style.transform = `translateY(${yOffset}px)`;
        card.style.transform = `rotateX(0deg) scale(1)`; // Keep full size even when hidden
        card.style.opacity = '0.3';
        card.style.zIndex = index + 1;
        card.classList.remove(styles.gameFlowCardActive);
      }
    });
  }, []);

  // Initialize component
  useEffect(() => {
    setIsInitialized(true);
    // Small delay to ensure DOM is ready
    const timer = setTimeout(() => {
      animateToCard(0); // Start with first card active
    }, 100);

    return () => clearTimeout(timer);
  }, [animateToCard]);

  // Reset when entering slide 10 (currentSection === 9)
  useEffect(() => {
    if (!isInitialized) return;

    if (currentSection === 9 && isScrollEnabled) {
      animateToCard(0);
    }
  }, [currentSection, isScrollEnabled, isInitialized, animateToCard]);

  // Handle subscroll functionality
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    // If scroll effect is disabled, don't add wheel listeners
    if (!isScrollEnabled) {
      return;
    }

    let wheelDelta = 0;
    let wheelTimer = null;

    const handleWheel = (e) => {
      if (isScrollingRef.current) return;

      e.preventDefault();
      e.stopPropagation();

      wheelDelta += e.deltaY;

      clearTimeout(wheelTimer);
      wheelTimer = setTimeout(() => {
        if (Math.abs(wheelDelta) > 100) {
          if (wheelDelta > 0 && activeCard < gameFlowCardsData.length - 1) {
            // Scroll down (next card)
            animateToCard(activeCard + 1);
          } else if (wheelDelta < 0 && activeCard > 0) {
            // Scroll up (previous card)
            animateToCard(activeCard - 1);
          } else if (wheelDelta < 0 && activeCard === 0) {
            // At first card, trigger previous section
            setTimeout(() => {
              if (window.gotoPrevSlide) {
                window.gotoPrevSlide();
              }
            }, 100);
          } else if (wheelDelta > 0 && activeCard === gameFlowCardsData.length - 1) {
            // At last card, trigger next section
            if (onAllColumnsVisible) {
              onAllColumnsVisible();
            }
            // Trigger main scroll to next section
            setTimeout(() => {
              if (window.gotoNextSlide) {
                window.gotoNextSlide();
              }
            }, 100);
          }
        }
        wheelDelta = 0;
      }, 100);
    };

    // Add event listener with capture to ensure it gets the event first
    container.addEventListener('wheel', handleWheel, { passive: false, capture: true });

    return () => {
      container.removeEventListener('wheel', handleWheel, { capture: true });
      clearTimeout(wheelTimer);
    };
  }, [isScrollEnabled, onAllColumnsVisible, isInitialized, gameFlowCardsData.length, activeCard, animateToCard]);

  return (
    <div className={styles.gameFlowNewContainer} ref={containerRef}>
      {/* Title at the very top */}
      <div style={{ 
        position: 'absolute', 
        top: '4rem', 
        left: '50%', 
        transform: 'translateX(-50%)', 
        zIndex: 100,
        width: '100%',
        textAlign: 'center'
      }}>
        <h3 className={styles.cubeTitle}>
        Play isn&apos;t escape; it&apos;s your return, where life rewrites the way you learn.
        </h3>
      </div>

      {/* Left Side - Overlapping Cards */}
      <div className={styles.gameFlowCardsSection}>
        <div className={styles.gameFlowCardsStack} ref={cardsStackRef}>
          {gameFlowCardsData.map((card, index) => (
            <div
              key={card.id}
              className={styles.gameFlowCardWrapper}
              style={{
                transform: `translateY(${index * 80 + 100}px)`,
                zIndex: index + 1
              }}
            >
              <div
                className={`${styles.gameFlowCard} ${activeCard === index ? styles.gameFlowCardActive : ''}`}
                style={{
                  '--card-color': card.color,
                  background: '#000000'
                }}
              >
                <div className={styles.gameFlowCardContent} style={{ textAlign: 'left', alignItems: 'flex-start', padding: '0 2rem' }}>
                  <h3 className={styles.gameFlowCardTitle} style={{ textAlign: 'left' }}>
                    <span style={{
                      fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                      fontSize: '26px',
                      color: '#00e87b',
                      fontWeight: 'normal',
                      textTransform: 'uppercase',
                      letterSpacing: '1px'
                    }}>
                      {card.title}
                    </span>
                  </h3>
                  <div className={styles.gameFlowCardTitleDivider} style={{ alignSelf: 'flex-start',}}></div>
                  <span className={styles.gameFlowCardSubtitle}>{card.subtitle}</span>
                  <p className={styles.gameFlowCardDescription}>{card.description}</p>
                  <div className={styles.gameFlowCardNumber}>{String(index + 1).padStart(2, '0')}</div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Right Side - Static Image */}
      <div className={styles.gameFlowImagesSection}>
        <div className={styles.gameFlowImageContainer}>
          <div className={styles.gameFlowImage}>
            <Image
              src="https://lidbucketnew.s3.ap-south-1.amazonaws.com/avatar/avatar1.svg"
              width={500}
              height={500}
              alt="Game Flow"
              className={styles.gameFlowImageContent}
            />
          </div>
        </div>
      </div>
    </div>
  );
};

// ScrollRevealSection component for slide 8 (Powers vs Forces) - Copy of working slide 7 pattern
const ScrollRevealSectionSlide8 = ({ onAllColumnsVisible, currentSection, isScrollEnabled = true }) => {
  const containerRef = useRef(null);
  const [visibleColumns, setVisibleColumns] = useState(isScrollEnabled ? 0 : 6);
  const [skipTransitions, setSkipTransitions] = useState(true); // Start with transitions disabled
  const [isInitialized, setIsInitialized] = useState(false);
  const columnsRef = useRef([]);
  const scrollTimeoutRef = useRef(null);
  const isScrollingRef = useRef(false);

  // Refs for controlling flipping words manually
  const yourPowersFlipRef = useRef(null);
  const theForcesFlipRef = useRef(null);

  // Track which columns have been triggered to prevent re-triggering
  const [triggeredColumns, setTriggeredColumns] = useState(new Set());

  // Initialize component with proper state to prevent flash
  useEffect(() => {
    // Set initial state immediately without transitions
    setSkipTransitions(true);
    setVisibleColumns(isScrollEnabled ? 0 : 6);

    // Enable transitions after a brief delay to prevent flash
    const timer = setTimeout(() => {
      setSkipTransitions(false);
      setIsInitialized(true);
    }, 100);

    return () => clearTimeout(timer);
  }, []);

  // Reset visible columns when isScrollEnabled changes
  useEffect(() => {
    if (!isInitialized) return; // Don't run until initialized

    setSkipTransitions(true); // Disable transitions during state change

    if (!isScrollEnabled) {
      setVisibleColumns(6);
      if (onAllColumnsVisible) {
        onAllColumnsVisible();
      }
    } else {
      setVisibleColumns(0); // Start with no grid points visible when scroll effect is enabled
      // Set initial scroll position to match step 0
      const container = containerRef.current;
      if (container) {
        const scrollHeight = container.scrollHeight;
        const containerHeight = container.clientHeight;
        const maxScroll = scrollHeight - containerHeight;
        container.scrollTop = 0; // Step 0 position
      }
    }

    // Re-enable transitions after state change
    setTimeout(() => {
      setSkipTransitions(false);
    }, 50);
  }, [isScrollEnabled, onAllColumnsVisible, isInitialized]);

  // Reset to initial state when entering slide 8 (currentSection === 7)
  useEffect(() => {
    if (!isInitialized) return;

    if (currentSection === 7 && isScrollEnabled) {
      // Reset to initial state when entering slide 8
      setSkipTransitions(true);
      setVisibleColumns(0);
      setTriggeredColumns(new Set()); // Reset triggered columns

      // Set initial scroll position
      const container = containerRef.current;
      if (container) {
        const scrollHeight = container.scrollHeight;
        const containerHeight = container.clientHeight;
        const maxScroll = scrollHeight - containerHeight;
        container.scrollTop = 0; // Step 0 position
      }

      // Re-enable transitions after reset
      setTimeout(() => {
        setSkipTransitions(false);
      }, 100);
    }
  }, [currentSection, isScrollEnabled, isInitialized]);

  // Trigger flipping animations when visibleColumns changes (for slide 8)
  useEffect(() => {
    if (isInitialized && visibleColumns >= 1) {
      // Trigger YOUR POWERS when it becomes visible (step 1)
      if (visibleColumns >= 1 && yourPowersFlipRef.current && !triggeredColumns.has(1)) {
        setTimeout(() => {
          yourPowersFlipRef.current.triggerFlip();
          setTriggeredColumns(prev => new Set(prev).add(1));
        }, 200);
      }

      // Trigger THE FORCES when it becomes visible (step 2)
      if (visibleColumns >= 2 && theForcesFlipRef.current && !triggeredColumns.has(2)) {
        setTimeout(() => {
          theForcesFlipRef.current.triggerFlip();
          setTriggeredColumns(prev => new Set(prev).add(2));
        }, 400);
      }
    }
  }, [visibleColumns, isInitialized, triggeredColumns]);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    // If scroll effect is disabled, don't add wheel listeners
    if (!isScrollEnabled) {
      return;
    }

    let wheelDelta = 0;
    let wheelTimer = null;
    let currentStep = 0; // 0, 1, 2 for each reveal step (start from 0)

    const smoothScrollToStep = (step, skipAnimation = false) => {
      if (isScrollingRef.current) return;
      isScrollingRef.current = true;

      const scrollHeight = container.scrollHeight;
      const containerHeight = container.clientHeight;
      const maxScroll = scrollHeight - containerHeight;

      // Define precise scroll positions for each step (8-step sequence)
      const scrollPositions = [
        0,                    // Step 0: Only separator line + top text visible
        maxScroll * 0.125,    // Step 1: "YOUR POWERS" header appears
        maxScroll * 0.25,     // Step 2: "THE FORCES" header appears
        maxScroll * 0.375,    // Step 3: First grid items (both columns)
        maxScroll * 0.5,      // Step 4: Second grid items (both columns)
        maxScroll * 0.625,    // Step 5: Third grid items (both columns)
        maxScroll * 0.75,     // Step 6: Fourth grid items (both columns)
        maxScroll * 0.875,    // Step 7: All content visible
        maxScroll             // Step 8: Complete (triggers next slide)
      ];

      const targetScroll = scrollPositions[step] || 0;

      // Update state immediately and skip animation if requested
      if (skipAnimation || step === 0) {
        setSkipTransitions(true);
        container.scrollTop = targetScroll;
        setVisibleColumns(step);
        currentStep = step;
        isScrollingRef.current = false;

        // Re-enable transitions after a brief moment
        setTimeout(() => {
          setSkipTransitions(false);
        }, 50);

        // Notify parent when all columns are visible
        if (step === 7 && onAllColumnsVisible) {
          onAllColumnsVisible();
        }

        return;
      }

      // Smooth scroll animation using requestAnimationFrame
      const startScroll = container.scrollTop;
      const distance = targetScroll - startScroll;
      const duration = 800; // 800ms for smooth animation
      const startTime = performance.now();

      const animateScroll = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Easing function for smooth animation (easeInOutCubic)
        const easeProgress = progress < 0.5
          ? 4 * progress * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 3) / 2;

        container.scrollTop = startScroll + (distance * easeProgress);

        if (progress < 1) {
          requestAnimationFrame(animateScroll);
        } else {
          isScrollingRef.current = false;

          // Update visible columns based on step
          setVisibleColumns(step);
          currentStep = step;

          // Notify parent when all columns are visible
          if (step === 7 && onAllColumnsVisible) {
            onAllColumnsVisible();
          }

          // Auto-advance to next slide when reaching step 8
          if (step >= 8 && currentSection === 7) {
            setTimeout(() => {
              // Double check we're still on slide 8 before advancing
              if (window.gotoNextSlide && currentSection === 7) {
                window.gotoNextSlide();
              }
            }, 300);
          }
        }
      };

      requestAnimationFrame(animateScroll);
    };

    const handleWheel = (e) => {
      e.preventDefault();

      if (isScrollingRef.current) return;

      // Accumulate wheel delta
      wheelDelta += e.deltaY;

      // Clear existing timer
      if (wheelTimer) {
        clearTimeout(wheelTimer);
      }

      // Wait for wheel events to settle
      wheelTimer = setTimeout(() => {
        if (Math.abs(wheelDelta) > 30) { // Lower threshold for more responsive
          if (wheelDelta > 0) {
            // Scroll down - next step
            const nextStep = Math.min(currentStep + 1, 8);
            smoothScrollToStep(nextStep);
          } else {
            // Scroll up - previous step or go to previous slide
            if (currentStep === 0) {
              // At the beginning (step 0), go to previous slide
              if (window.gotoPrevSlide) {
                window.gotoPrevSlide();
              }
            } else {
              const prevStep = Math.max(currentStep - 1, 0);
              smoothScrollToStep(prevStep);
            }
          }
        }
        wheelDelta = 0; // Reset delta
      }, 5); // Very short delay
    };

    container.addEventListener('wheel', handleWheel, { passive: false });

    return () => {
      container.removeEventListener('wheel', handleWheel);
      if (wheelTimer) clearTimeout(wheelTimer);
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);
    };
  }, [onAllColumnsVisible, isScrollEnabled]);

  return (
    <div
      ref={containerRef}
      className={styles.scrollRevealContainer}
      style={{
        height: '100vh',
        overflowY: 'auto',
        overflowX: 'hidden'
      }}
    >
      <div style={{ height: '200vh', position: 'relative' }}>
        <div className={styles.powersContainer} style={{
          position: 'sticky',
          top: 0,
          height: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center'
        }}>
          {/* Top text - visible from step 0 */}
          <div
            className={styles.powersTopText}
            style={{
              opacity: visibleColumns >= 0 ? 1 : 0,
              transform: visibleColumns >= 0 ? 'translateY(0)' : 'translateY(-30px)',
              transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease',
              marginBottom: '5px',
              textAlign: 'center'
            }}
          >
            <p className={styles.heroParagraph} style={{
              fontFamily: '"satoshi", sans-serif',
              fontSize: '14px',
              fontWeight: '500',
              letterSpacing: '1px',
              color: '#888888',
              marginBottom: "-0.4rem",
            }}>
              Between They and I lies the true plot ‚Äîthe moment you realize who‚Äôs been designing your lot.
            </p>
          </div>

          <div className={styles.powersMainContent}>
            <div
              ref={el => columnsRef.current[0] = el}
              className={`${styles.powersSection} ${!isInitialized ? styles.gridColumnInitial : ''}`}
            >
              <h3
                className={styles.sectionTitle}
                style={{
                  opacity: visibleColumns >= 1 ? 1 : 0,
                  transform: visibleColumns >= 1 ? 'translateY(0)' : 'translateY(30px)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.1s'
                }}
              >
                <h3 style={{
                  fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                  fontSize: '26px',
                  color: '#00e87b',
                  fontWeight: 'normal',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                  margin: 0
                }}>
                  The Designer
                </h3>
              </h3>
              <p
                className={styles.heroParagraph}
                style={{
                  opacity: visibleColumns >= 1 ? 1 : 0,
                  transform: visibleColumns >= 1 ? 'translateY(0)' : 'translateY(30px)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s',
                  textAlign: 'center'
                }}
              >
                You're not a pawn in someone's frame,<br />
                you are the architect of your game.
              </p>

              <div className={`${styles.powersGrid2x2}`}>
                <div className={styles.cardWrapper}>
                <div
                  className={styles.hoverCard}
                  style={{
                    opacity: visibleColumns >= 3 ? 1 : 0,
                    transform: visibleColumns >= 3 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
                  }}
                >
                  <div className={styles.cardContent}>
                      <div className={styles.cardEmoji}>üß†</div>
                      <div className={styles.cardHoverContent}>
                    <p className={styles.cardDescription}>The compass no one can cloud.</p>
                  </div>
                </div>
                  </div>
                  <h4 
                    className={styles.cardTitleBelow}
                    style={{
                      opacity: visibleColumns >= 3 ? 1 : 0,
                      transform: visibleColumns >= 3 ? 'translateY(0)' : 'translateY(30px)',
                      transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
                    }}
                  >Intuition
</h4>
                </div>
                <div className={styles.cardWrapper}>
                <div
                  className={styles.hoverCard}
                  style={{
                    opacity: visibleColumns >= 4 ? 1 : 0,
                    transform: visibleColumns >= 4 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.1s'
                  }}
                >
                  <div className={styles.cardContent}>
                      <div className={styles.cardEmoji}>üéØ</div>
                      <div className={styles.cardHoverContent}>
                    <p className={styles.cardDescription}>the compass no one can cloud.</p>
                  </div>
                </div>
                  </div>
                  <h4 
                    className={styles.cardTitleBelow}
                    style={{
                      opacity: visibleColumns >= 4 ? 1 : 0,
                      transform: visibleColumns >= 4 ? 'translateY(0)' : 'translateY(30px)',
                      transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.1s'
                    }}
                  >Inner Voice</h4>
                </div>
                <div className={styles.cardWrapper}>
                <div
                  className={styles.hoverCard}
                  style={{
                    opacity: visibleColumns >= 5 ? 1 : 0,
                    transform: visibleColumns >= 5 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
                  }}
                >
                  <div className={styles.cardContent}>
                      <div className={styles.cardEmoji}>‚ö°</div>
                      <div className={styles.cardHoverContent}>
                    <p className={styles.cardDescription}>The step before you know.</p>
                  </div>
                </div>
                  </div>
                  <h4 
                    className={styles.cardTitleBelow}
                    style={{
                      opacity: visibleColumns >= 5 ? 1 : 0,
                      transform: visibleColumns >= 5 ? 'translateY(0)' : 'translateY(30px)',
                      transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
                    }}
                  >Instinct</h4>
                </div>
                <div className={styles.cardWrapper}>
                <div
                  className={styles.hoverCard}
                  style={{
                    opacity: visibleColumns >= 6 ? 1 : 0,
                    transform: visibleColumns >= 6 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.3s'
                  }}
                >
                  <div className={styles.cardContent}>
                      <div className={styles.cardEmoji}>üöÄ</div>
                      <div className={styles.cardHoverContent}>
                    <p className={styles.cardDescription}>The storm that makes you grow.</p>
                  </div>
                    </div>
                  </div>
                  <h4 
                    className={styles.cardTitleBelow}
                    style={{
                      opacity: visibleColumns >= 6 ? 1 : 0,
                      transform: visibleColumns >= 6 ? 'translateY(0)' : 'translateY(30px)',
                      transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.3s'
                    }}
                  >Risk</h4>
                </div>
              </div>
            </div>

            <div className={styles.separatorLine}></div>

            <div
              ref={el => columnsRef.current[1] = el}
              className={`${styles.forcesSection} ${!isInitialized && isScrollEnabled ? styles.gridColumnInitial : ''}`}
            >
              <h3
                className={styles.sectionTitle}
                style={{
                  opacity: visibleColumns >= 2 ? 1 : 0,
                  transform: visibleColumns >= 2 ? 'translateY(0)' : 'translateY(30px)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.1s'
                }}
              >
                <h3 style={{
                  fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                  fontSize: '26px',
                  color: '#00e87b',
                  fontWeight: 'normal',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                  margin: 0
                }}>
                 The Design
                </h3>
              </h3>
              <p
                className={styles.heroParagraph}
                style={{
                  opacity: visibleColumns >= 2 ? 1 : 0,
                  transform: visibleColumns >= 2 ? 'translateY(0)' : 'translateY(30px)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s',
                  textAlign: 'center'
                }}
              >
                They forged the maze and called it fate,
                a loop designed to captivate.
              </p>

              <div className={`${styles.forcesGrid2x2}`}>
                <div className={styles.cardWrapper}>
                <div
                  className={styles.hoverCard}
                  style={{
                    opacity: visibleColumns >= 3 ? 1 : 0,
                    transform: visibleColumns >= 3 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
                  }}
                >
                  <div className={styles.cardContent}>
                      <div className={styles.cardEmoji}>üèõÔ∏è</div>
                      <div className={styles.cardHoverContent}>
                    <p className={styles.cardDescription}> The mirror that keeps you blind.</p>
                  </div>
                </div>
                  </div>
                  <h4 
                    className={styles.cardTitleBelow}
                    style={{
                      opacity: visibleColumns >= 3 ? 1 : 0,
                      transform: visibleColumns >= 3 ? 'translateY(0)' : 'translateY(30px)',
                      transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
                    }}
                  >Society</h4>
                </div>
                <div className={styles.cardWrapper}>
                <div
                  className={styles.hoverCard}
                  style={{
                    opacity: visibleColumns >= 4 ? 1 : 0,
                    transform: visibleColumns >= 4 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.1s'
                  }}
                >
                  <div className={styles.cardContent}>
                      <div className={styles.cardEmoji}>üèõÔ∏è</div>
                      <div className={styles.cardHoverContent}>
                    <p className={styles.cardDescription}>The script that traps your mind.</p>
                  </div>
                </div>
                  </div>
                  <h4 
                    className={styles.cardTitleBelow}
                    style={{
                      opacity: visibleColumns >= 4 ? 1 : 0,
                      transform: visibleColumns >= 4 ? 'translateY(0)' : 'translateY(30px)',
                      transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.1s'
                    }}
                  >Government</h4>
                </div>
                <div className={styles.cardWrapper}>
                <div
                  className={styles.hoverCard}
                  style={{
                    opacity: visibleColumns >= 5 ? 1 : 0,
                    transform: visibleColumns >= 5 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
                  }}
                >
                  <div className={styles.cardContent}>
                      <div className={styles.cardEmoji}>‚õ™</div>
                      <div className={styles.cardHoverContent}>
                    <p className={styles.cardDescription}>The voice that shapes your fear.</p>
                  </div>
                </div>
                  </div>
                  <h4 
                    className={styles.cardTitleBelow}
                    style={{
                      opacity: visibleColumns >= 5 ? 1 : 0,
                      transform: visibleColumns >= 5 ? 'translateY(0)' : 'translateY(30px)',
                      transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
                    }}
                  >Religion</h4>
                </div>
                <div className={styles.cardWrapper}>
                <div
                  className={styles.hoverCard}
                  style={{
                    opacity: visibleColumns >= 6 ? 1 : 0,
                    transform: visibleColumns >= 6 ? 'translateY(0)' : 'translateY(30px)',
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.3s'
                  }}
                >
                  <div className={styles.cardContent}>
                      <div className={styles.cardEmoji}>üì∫</div>
                      <div className={styles.cardHoverContent}>
                    <p className={styles.cardDescription}> The noise that drowns your goal.</p>
                  </div>
                    </div>
                  </div>
                  <h4 
                    className={styles.cardTitleBelow}
                    style={{
                      opacity: visibleColumns >= 6 ? 1 : 0,
                      transform: visibleColumns >= 6 ? 'translateY(0)' : 'translateY(30px)',
                      transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.3s'
                    }}
                  >Media</h4>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

// ScrollRevealSection component for slide 5
const ScrollRevealSectionSlide5 = ({ onAllColumnsVisible, currentSection, isScrollEnabled = true }) => {
  const containerRef = useRef(null);
  const [visibleColumns, setVisibleColumns] = useState(isScrollEnabled ? 0 : 3);
  const [skipTransitions, setSkipTransitions] = useState(true); // Start with transitions disabled
  const [isInitialized, setIsInitialized] = useState(false);
  const columnsRef = useRef([]);
  const scrollTimeoutRef = useRef(null);
  const isScrollingRef = useRef(false);

  // Refs for controlling flipping words manually
  const speculateFlipRef = useRef(null);
  const evaluateFlipRef = useRef(null);
  const integrateFlipRef = useRef(null);

  // Track which columns have been triggered to prevent re-triggering
  const [triggeredColumns, setTriggeredColumns] = useState(new Set());

  // Initialize component with proper state to prevent flash
  useEffect(() => {
    // Set initial state immediately without transitions
    setSkipTransitions(true);
    setVisibleColumns(isScrollEnabled ? 0 : 3);

    // Enable transitions after a brief delay to prevent flash
    const timer = setTimeout(() => {
      setSkipTransitions(false);
      setIsInitialized(true);
    }, 100);

    return () => clearTimeout(timer);
  }, []);

  // Reset visible columns when isScrollEnabled changes
  useEffect(() => {
    if (!isInitialized) return; // Don't run until initialized

    setSkipTransitions(true); // Disable transitions during state change

    if (!isScrollEnabled) {
      setVisibleColumns(6);
      if (onAllColumnsVisible) {
        onAllColumnsVisible();
      }
    } else {
      setVisibleColumns(0); // Start with no columns when scroll effect is enabled
      // Set initial scroll position to match step 0
      const container = containerRef.current;
      if (container) {
        container.scrollTop = 0; // Step 0 position
      }
    }

    // Re-enable transitions after state change
    setTimeout(() => {
      setSkipTransitions(false);
    }, 50);
  }, [isScrollEnabled, onAllColumnsVisible, isInitialized]);

  // Reset to initial state when entering slide 5 (currentSection === 4)
  useEffect(() => {
    if (!isInitialized) return;

    if (currentSection === 4 && isScrollEnabled) {
      // Reset to initial state when entering slide 5
      setSkipTransitions(true);
      setVisibleColumns(0);
      setTriggeredColumns(new Set()); // Reset triggered columns

      // Set initial scroll position
      const container = containerRef.current;
      if (container) {
        container.scrollTop = 0; // Step 0 position
      }

      // Re-enable transitions after reset
      setTimeout(() => {
        setSkipTransitions(false);
      }, 100);
    }
  }, [currentSection, isScrollEnabled, isInitialized]);

  // Trigger flipping animations when visibleColumns changes (for slide 5)
  useEffect(() => {
    if (isInitialized && visibleColumns >= 1) {
      // Trigger INTEGRATE (column 3) when it becomes visible (step 1)
      if (visibleColumns >= 1 && integrateFlipRef.current && !triggeredColumns.has(3)) {
        setTimeout(() => {
          integrateFlipRef.current.triggerFlip();
          setTriggeredColumns(prev => new Set(prev).add(3));
        }, 200);
      }

      // Trigger EVALUATE (column 2) when it becomes visible (step 2)
      if (visibleColumns >= 2 && evaluateFlipRef.current && !triggeredColumns.has(2)) {
        setTimeout(() => {
          evaluateFlipRef.current.triggerFlip();
          setTriggeredColumns(prev => new Set(prev).add(2));
        }, 400);
      }

      // Trigger SPECULATE (column 1) when it becomes visible (step 3)
      if (visibleColumns >= 3 && speculateFlipRef.current && !triggeredColumns.has(1)) {
        setTimeout(() => {
          speculateFlipRef.current.triggerFlip();
          setTriggeredColumns(prev => new Set(prev).add(1));
        }, 600);
      }
    }
  }, [visibleColumns, isInitialized, triggeredColumns]);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    // If scroll effect is disabled, don't add wheel listeners
    if (!isScrollEnabled) {
      return;
    }

    let wheelDelta = 0;
    let wheelTimer = null;
    let currentStep = 0; // 0, 1, 2, 3 for each column reveal step (start from 0)

    const smoothScrollToStep = (step, skipAnimation = false) => {
      if (isScrollingRef.current) return;
      isScrollingRef.current = true;

      const scrollHeight = container.scrollHeight;
      const containerHeight = container.clientHeight;
      const maxScroll = scrollHeight - containerHeight;

      // Define precise scroll positions for each step
      const scrollPositions = [
        0,                    // Step 0: No columns visible
        maxScroll * 0.2,      // Step 1: First column
        maxScroll * 0.45,     // Step 2: Second column  
        maxScroll * 0.7,      // Step 3: Third column
        maxScroll             // Step 4: Complete (triggers next slide)
      ];

      const targetScroll = scrollPositions[step] || 0;

      // Update state immediately and skip animation if requested
      if (skipAnimation || step === 0) {
        setSkipTransitions(true);
        container.scrollTop = targetScroll;
        setVisibleColumns(step);
        currentStep = step;
        isScrollingRef.current = false;

        // Re-enable transitions after a brief moment
        setTimeout(() => {
          setSkipTransitions(false);
        }, 50);

        // Notify parent when all columns are visible
        if (step === 3 && onAllColumnsVisible) {
          onAllColumnsVisible();
        }

        return;
      }

      // Smooth scroll animation using requestAnimationFrame
      const startScroll = container.scrollTop;
      const distance = targetScroll - startScroll;
      const duration = 800; // 800ms for smooth animation
      const startTime = performance.now();

      const animateScroll = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Easing function for smooth animation (easeInOutCubic)
        const easeProgress = progress < 0.5
          ? 4 * progress * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 3) / 2;

        container.scrollTop = startScroll + (distance * easeProgress);

        if (progress < 1) {
          requestAnimationFrame(animateScroll);
        } else {
          isScrollingRef.current = false;

          // Update visible columns based on step
          setVisibleColumns(step);
          currentStep = step;

          // Notify parent when all columns are visible
          if (step === 3 && onAllColumnsVisible) {
            onAllColumnsVisible();
          }

          // Auto-advance to next slide when reaching step 4
          if (step >= 4 && currentSection === 4) {
            setTimeout(() => {
              // Double check we're still on slide 5 before advancing
              if (window.gotoNextSlide && currentSection === 4) {
                window.gotoNextSlide();
              }
            }, 300);
          }
        }
      };

      requestAnimationFrame(animateScroll);
    };

    const handleWheel = (e) => {
      e.preventDefault();

      if (isScrollingRef.current) return;

      // Accumulate wheel delta
      wheelDelta += e.deltaY;

      // Clear existing timer
      if (wheelTimer) {
        clearTimeout(wheelTimer);
      }

      // Wait for wheel events to settle
      wheelTimer = setTimeout(() => {
        if (Math.abs(wheelDelta) > 30) { // Lower threshold for more responsive
          if (wheelDelta > 0) {
            // Scroll down - next step
            const nextStep = Math.min(currentStep + 1, 4);
            smoothScrollToStep(nextStep);
          } else {
            // Scroll up - previous step or go to previous slide
            if (currentStep === 0) {
              // At the beginning (step 0), go to previous slide
              if (window.gotoPrevSlide) {
                window.gotoPrevSlide();
              }
            } else {
              const prevStep = Math.max(currentStep - 1, 0);
              smoothScrollToStep(prevStep);
            }
          }
        }
        wheelDelta = 0; // Reset delta
      }, 5); // Very short delay
    };

    container.addEventListener('wheel', handleWheel, { passive: false });

    return () => {
      container.removeEventListener('wheel', handleWheel);
      if (wheelTimer) clearTimeout(wheelTimer);
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);
    };
  }, [onAllColumnsVisible, isScrollEnabled]);

  return (
    <div
      ref={containerRef}
      className={styles.scrollRevealContainer}
      style={{
        height: '100vh',
        overflowY: 'auto',
        overflowX: 'hidden'
      }}
    >
      <div style={{ height: '200vh', position: 'relative' }}>
        <div className={styles.featuresContainer} style={{
          position: 'sticky',
          top: 0,
          height: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center'
        }}>
          {/* Top text - always visible */}
          <div
            className={styles.featuresTopText}
            style={{
              opacity: 1,
              transform: 'translateY(0)',
              marginBottom: '40px',
              textAlign: 'center'
            }}
          >
            <p className={styles.heroParagraph} style={{
              fontFamily: '"satoshi", sans-serif',
              fontSize: '14px',
              fontWeight: '500',
              letterSpacing: '1px',
              color: '#888888'
            }}>
              Together, they form the rhythm of creation ‚Äîwhere thought turns to focus, and focus to manifestation.
            </p>
          </div>

          <div className={styles.threeColumnGrid} style={{ marginBottom: 0 }}>
            <div
              ref={el => columnsRef.current[0] = el}
              className={`${styles.gridColumn} ${!isInitialized ? styles.gridColumnInitial : ''}`}
              style={{
                opacity: visibleColumns >= 3 ? 1 : 0,
                transform: visibleColumns >= 3 ? 'translateX(0)' : 'translateX(-100px)',
                transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.4s'
              }}
            >
              <div className={styles.columnTitle}>
                <h3 style={{
                  fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                  fontSize: '26px',
                  color: '#00e87b',
                  fontWeight: 'normal',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                  margin: 0
                }}>
                  SPECULATE
                </h3>
              </div>
              <div className={styles.textContent}>
                <p className={styles.heroParagraph} style={{
                  fontFamily: '"satoshi", sans-serif',
                  fontSize: '14px',
                  fontWeight: '500',
                  letterSpacing: '1px',
                  color: '#888888'
                }}>
                  Imagine beyond what eyes can see,
                  Design the "what if" that sets you free.
                </p>
              </div>
              <div className={styles.imageContent}>
                <Image
                  src={lifeidesignsvg}
                  width={200}
                  height={200}
                  alt="Life i Design Game"
                  className={styles.heroImageContent}
                />
              </div>
            </div>

            <div
              ref={el => columnsRef.current[1] = el}
              className={`${styles.gridColumn} ${!isInitialized && isScrollEnabled ? styles.gridColumnInitial : ''}`}
              style={{
                opacity: visibleColumns >= 2 ? 1 : 0,
                transform: visibleColumns >= 2 ? 'translateX(0)' : 'translateX(-100px)',
                transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
              }}
            >
              <div className={styles.columnTitle}>
                <h3 style={{
                  fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                  fontSize: '26px',
                  color: '#00e87b',
                  fontWeight: 'normal',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                  margin: 0
                }}>
                  EVALUATE
                </h3>
              </div>
              <div className={styles.textContent}>
                <p className={styles.heroParagraph} style={{
                  fontFamily: '"satoshi", sans-serif',
                  fontSize: '14px',
                  fontWeight: '500',
                  letterSpacing: '1px',
                  color: '#888888'
                }}>
                  Still the static, decode your core
                  The self you seek is what you're for.
                </p>
              </div>
              <div className={styles.imageContent}>
                <Image
                  src={lifeidesignsvg}
                  width={200}
                  height={200}
                  alt="Life i Design Game"
                  className={styles.heroImageContent}
                />
              </div>
            </div>

            <div
              ref={el => columnsRef.current[2] = el}
              className={`${styles.gridColumn} ${!isInitialized && isScrollEnabled ? styles.gridColumnInitial : ''}`}
              style={{
                opacity: visibleColumns >= 1 ? 1 : 0,
                transform: visibleColumns >= 1 ? 'translateX(0)' : 'translateX(-100px)',
                transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
              }}
            >
              <div className={styles.columnTitle}>
                <h3 style={{
                  fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                  fontSize: '26px',
                  color: '#00e87b',
                  fontWeight: 'normal',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                  margin: 0
                }}>
                  INTEGRATE
                </h3>
              </div>
              <div className={styles.textContent}>
                <p className={styles.heroParagraph} style={{
                  fontFamily: '"satoshi", sans-serif',
                  fontSize: '14px',
                  fontWeight: '500',
                  letterSpacing: '1px',
                  color: '#888888'
                }}>
                  Turn your insight into motion's flame,
                  Let the imagined and the lived, become the same.
                </p>
              </div>
              <div className={styles.imageContent}>
                <Image
                  src={lifeidesignsvg}
                  width={200}
                  height={200}
                  alt="Life i Design Game"
                  className={styles.heroImageContent}
                />
              </div>
            </div>
          </div>

          {/* Progress Indicator Line */}
          <div className={styles.columnProgressIndicator}>
            <div className={styles.progressLine}>
              <div
                className={styles.progressSegment}
                style={{
                  opacity: visibleColumns >= 3 ? 1 : 0,
                  transform: visibleColumns >= 3 ? 'scale(1)' : 'scale(0)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
                }}
              >
                <div
                  className={`${styles.progressNumber} ${visibleColumns >= 3 ? styles.progressActive : ''}`}
                  style={{
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
                  }}
                >
                </div>
              </div>
              <div
                className={`${styles.progressConnector} ${visibleColumns >= 3 ? styles.progressActive : ''}`}
                style={{
                  opacity: visibleColumns >= 3 ? 1 : 0,
                  transform: visibleColumns >= 3 ? 'scaleX(1)' : 'scaleX(0)',
                  transformOrigin: 'right',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.1s'
                }}
              ></div>
              <div
                className={styles.progressSegment}
                style={{
                  opacity: visibleColumns >= 2 ? 1 : 0,
                  transform: visibleColumns >= 2 ? 'scale(1)' : 'scale(0)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
                }}
              >
                <div
                  className={`${styles.progressNumber} ${visibleColumns >= 2 ? styles.progressActive : ''}`}
                  style={{
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
                  }}
                >
                </div>
              </div>
              <div
                className={`${styles.progressConnector} ${visibleColumns >= 2 ? styles.progressActive : ''}`}
                style={{
                  opacity: visibleColumns >= 2 ? 1 : 0,
                  transform: visibleColumns >= 2 ? 'scaleX(1)' : 'scaleX(0)',
                  transformOrigin: 'right',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.3s'
                }}
              ></div>
              <div
                className={styles.progressSegment}
                style={{
                  opacity: visibleColumns >= 1 ? 1 : 0,
                  transform: visibleColumns >= 1 ? 'scale(1)' : 'scale(0)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.4s'
                }}
              >
                <div
                  className={`${styles.progressNumber} ${visibleColumns >= 1 ? styles.progressActive : ''}`}
                  style={{
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.4s'
                  }}
                >
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

// ScrollRevealSection component for slide 3 (Demo)
const ScrollRevealSectionSlide3 = ({ onAllColumnsVisible, currentSection, isScrollEnabled = true, currentVideoIndex, setCurrentVideoIndex, videoStates, setVideoStates, videoRefs, togglePlayPause, updateProgress, updateDuration, seekVideo }) => {
  const containerRef = useRef(null);
  const [visibleColumns, setVisibleColumns] = useState(isScrollEnabled ? 0 : 2);
  const [skipTransitions, setSkipTransitions] = useState(true);
  const [isInitialized, setIsInitialized] = useState(false);
  const scrollTimeoutRef = useRef(null);
  const isScrollingRef = useRef(false);

  // Initialize component with proper state to prevent flash
  useEffect(() => {
    setSkipTransitions(true);
    setVisibleColumns(isScrollEnabled ? 1 : 2); // Start with title visible (step 1)

    const timer = setTimeout(() => {
      setSkipTransitions(false);
      setIsInitialized(true);
    }, 100);

    return () => clearTimeout(timer);
  }, [isScrollEnabled]);

  // Reset visible columns when isScrollEnabled changes
  useEffect(() => {
    if (!isInitialized) return;

    setSkipTransitions(true);

    if (!isScrollEnabled) {
      setVisibleColumns(2);
      if (onAllColumnsVisible) {
        onAllColumnsVisible();
      }
    } else {
      setVisibleColumns(1); // Start with title visible
      const container = containerRef.current;
      if (container) {
        container.scrollTop = 0;
      }
    }

    setTimeout(() => {
      setSkipTransitions(false);
    }, 50);
  }, [isScrollEnabled, onAllColumnsVisible, isInitialized]);

  // Reset to initial state when entering slide 3 (currentSection === 2)
  useEffect(() => {
    if (!isInitialized) return;

    if (currentSection === 2 && isScrollEnabled) {
      setSkipTransitions(true);
      setVisibleColumns(1); // Start with title visible

      const container = containerRef.current;
      if (container) {
        container.scrollTop = 0;
      }

      setTimeout(() => {
        setSkipTransitions(false);
      }, 100);
    }
  }, [currentSection, isScrollEnabled, isInitialized]);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    if (!isScrollEnabled) {
      return;
    }

    let wheelDelta = 0;
    let wheelTimer = null;
    let currentStep = 1; // Start at step 1 (title visible)

    const smoothScrollToStep = (step, skipAnimation = false) => {
      if (isScrollingRef.current) return;
      isScrollingRef.current = true;

      const scrollHeight = container.scrollHeight;
      const containerHeight = container.clientHeight;
      const maxScroll = scrollHeight - containerHeight;

      // Define precise scroll positions for each step
      const scrollPositions = [
        0,                    // Step 0: Title visible (initial state)
        maxScroll * 0.33,     // Step 1: Video carousel appears
        maxScroll * 0.66,     // Step 2: Video carousel fully visible
        maxScroll             // Step 3: Complete (triggers next slide)
      ];

      const targetScroll = scrollPositions[step] || 0;

      if (skipAnimation || step === 0) {
        setSkipTransitions(true);
        container.scrollTop = targetScroll;
        setVisibleColumns(step);
        currentStep = step;
        isScrollingRef.current = false;

        setTimeout(() => {
          setSkipTransitions(false);
        }, 50);

        // Notify parent when video carousel is fully visible
        if (step === 2 && onAllColumnsVisible) {
          onAllColumnsVisible();
        }

        return;
      }

      const startScroll = container.scrollTop;
      const distance = targetScroll - startScroll;
      const duration = 800;
      const startTime = performance.now();

      const animateScroll = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        const easeProgress = progress < 0.5
          ? 4 * progress * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 3) / 2;

        container.scrollTop = startScroll + (distance * easeProgress);

        if (progress < 1) {
          requestAnimationFrame(animateScroll);
        } else {
          isScrollingRef.current = false;
          setVisibleColumns(step);
          currentStep = step;

          // Notify parent when video carousel is fully visible
          if (step === 2 && onAllColumnsVisible) {
            onAllColumnsVisible();
          }

          // Auto-advance to next slide when reaching step 3
          if (step >= 3 && currentSection === 2) {
            setTimeout(() => {
              // Double check we're still on slide 3 before advancing
              if (window.gotoNextSlide && currentSection === 2) {
                window.gotoNextSlide();
              }
            }, 300);
          }
        }
      };

      requestAnimationFrame(animateScroll);
    };

    const handleWheel = (e) => {
      e.preventDefault();

      if (isScrollingRef.current) return;

      wheelDelta += e.deltaY;

      if (wheelTimer) {
        clearTimeout(wheelTimer);
      }

      wheelTimer = setTimeout(() => {
        if (Math.abs(wheelDelta) > 30) { // Lower threshold for more responsive
          if (wheelDelta > 0) {
            // Scroll down - next step
            const nextStep = Math.min(currentStep + 1, 3);
            smoothScrollToStep(nextStep);
          } else {
            // Scroll up - previous step or go to previous slide
            if (currentStep === 1) {
              // At the beginning (step 1), go to previous slide
              if (window.gotoPrevSlide) {
                window.gotoPrevSlide();
              }
            } else {
              const prevStep = Math.max(currentStep - 1, 1);
              smoothScrollToStep(prevStep);
            }
          }
        }
        wheelDelta = 0; // Reset delta
      }, 5); // Very short delay
    };

    container.addEventListener('wheel', handleWheel, { passive: false });

    return () => {
      container.removeEventListener('wheel', handleWheel);
      if (wheelTimer) clearTimeout(wheelTimer);
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);
    };
  }, [onAllColumnsVisible, isScrollEnabled]);

  return (
    <div
      ref={containerRef}
      className={styles.scrollRevealContainer}
      style={{
        height: '100vh',
        overflowY: 'auto',
        overflowX: 'hidden'
      }}
    >
      <div style={{ height: '200vh', position: 'relative' }}>
        <div className={styles.heroLayout} style={{
          position: 'sticky',
          top: 0,
          height: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          <div className={styles.heroContent}>
            <div className={styles.heroText}>
              {/* Title - appears on step 1 */}
              <h3
                className={styles.cubeTitle}
                style={{
                  opacity: visibleColumns >= 1 ? 1 : 0,
                  transform: visibleColumns >= 1 ? 'translateY(0)' : 'translateY(30px)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.8s ease',
                  marginBottom: '2rem'
                }}
              >
                Behind every mask, someone finally became real
              </h3>

              {/* Video Carousel - appears on step 2 */}
              <div
                className={styles.videoCarouselSection}
                style={{
                  position: 'relative',
                  opacity: visibleColumns >= 2 ? 1 : 0,
                  transform: visibleColumns >= 2 ? 'translateY(0)' : 'translateY(50px)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.8s ease 0.2s'
                }}
              >
                {/* Left Arrow */}
                <button
                  className={styles.carouselNavButton}
                  onClick={() => setCurrentVideoIndex(prev => ((prev - 1) % 9 + 9) % 9)}
                  style={{
                    position: 'absolute',
                    left: '20px',
                    top: '50%',
                    transform: 'translateY(-50%)',
                    zIndex: 10
                  }}
                >
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M15 18l-6-6 6-6" />
                  </svg>
                </button>

                <div className={styles.videoCarousel}>
                  <div className={styles.videoCarouselWrapper}>
                    {Array.from({ length: 9 }, (_, index) => {
                      let offsetFromMiddle = index - currentVideoIndex;

                      if (offsetFromMiddle > 4) {
                        offsetFromMiddle -= 9;
                      } else if (offsetFromMiddle < -4) {
                        offsetFromMiddle += 9;
                      }

                      const distanceFactor = 1 - Math.abs(offsetFromMiddle / 3);
                      const translateX = offsetFromMiddle * 80;
                      const scale = Math.max(0.75, distanceFactor);
                      const opacity = Math.max(0.4, distanceFactor);
                      const zIndex = Math.abs(Math.abs(offsetFromMiddle) - 2);

                      return (
                        <div
                          key={index}
                          className={styles.videoCarouselSlide}
                          style={{
                            transform: `translateX(${translateX}%) scale(${scale})`,
                            opacity: opacity,
                            zIndex: zIndex,
                            visibility: Math.abs(offsetFromMiddle) > 0 ? 'hidden' : 'visible'
                          }}
                        >
                          <div className={styles.videoContainer}>
                            <div
                              className={styles.videoWrapper}
                              onMouseEnter={() => setVideoStates(prev => ({
                                ...prev,
                                [index]: { ...prev[index], isHovering: true }
                              }))}
                              onMouseLeave={() => setVideoStates(prev => ({
                                ...prev,
                                [index]: { ...prev[index], isHovering: false }
                              }))}
                            >
                              <video
                                ref={el => videoRefs.current[index] = el}
                                className={styles.demoVideo}
                                poster={`/api/placeholder/300/500?video=${index + 1}`}
                                onTimeUpdate={() => updateProgress(index)}
                                onLoadedMetadata={() => updateDuration(index)}
                                onClick={() => togglePlayPause(index)}
                              >
                                <source src="https://lidbucketnew.s3.ap-south-1.amazonaws.com/reviews/audio3.mp4" type="video/mp4" />
                                Your browser does not support the video tag.
                              </video>

                              <button
                                className={styles.centerPlayBtn}
                                onClick={() => togglePlayPause(index)}
                                style={{
                                  opacity: (!videoStates[index]?.isPlaying || videoStates[index]?.isHovering) ? 1 : 0,
                                  visibility: (!videoStates[index]?.isPlaying || videoStates[index]?.isHovering) ? 'visible' : 'hidden'
                                }}
                              >
                                <svg width="60" height="60" viewBox="0 0 24 24" fill="none">
                                  {videoStates[index]?.isPlaying ? (
                                    <>
                                      <rect x="8" y="5" width="3" height="14" rx="1" fill="#00e87b" />
                                      <rect x="13" y="5" width="3" height="14" rx="1" fill="#00e87b" />
                                    </>
                                  ) : (
                                    <polygon points="9,5 9,19 19,12" fill="#00e87b" />
                                  )}
                                </svg>
                              </button>
                            </div>

                            <div className={styles.customVideoControls}>
                              <div
                                className={styles.timelineContainer}
                                onClick={(e) => seekVideo(index, e)}
                              >
                                <div
                                  className={styles.timelineProgress}
                                  style={{ width: `${videoStates[index]?.progress || 0}%` }}
                                />
                              </div>
                            </div>
                          </div>
                        </div>
                      );
                    }).filter(Boolean)}
                  </div>
                </div>

                {/* Right Arrow */}
                <button
                  className={styles.carouselNavButton}
                  onClick={() => setCurrentVideoIndex(prev => (prev + 1) % 9)}
                  style={{
                    position: 'absolute',
                    right: '20px',
                    top: '50%',
                    transform: 'translateY(-50%)',
                    zIndex: 10
                  }}
                >
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M9 18l6-6-6-6" />
                  </svg>
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

// ScrollRevealSection component for slide 4
const ScrollRevealSectionSlide4 = ({ onAllColumnsVisible, currentSection, isScrollEnabled = true }) => {
  const containerRef = useRef(null);
  const [visibleColumns, setVisibleColumns] = useState(isScrollEnabled ? 0 : 3);
  const [skipTransitions, setSkipTransitions] = useState(true); // Start with transitions disabled
  const [isInitialized, setIsInitialized] = useState(false);
  const columnsRef = useRef([]);
  const scrollTimeoutRef = useRef(null);
  const isScrollingRef = useRef(false);

  // Refs for controlling flipping words manually
  const psychologyFlipRef = useRef(null);
  const philosophyFlipRef = useRef(null);
  const playFlipRef = useRef(null);

  // Track which columns have been triggered to prevent re-triggering
  const [triggeredColumns, setTriggeredColumns] = useState(new Set());

  // Function to trigger flipping animations based on visible columns
  const triggerFlippingAnimations = (step) => {
    // Skip PSYCHOLOGY (step 1) as it's triggered immediately when entering slide 4
    // Only trigger PHILOSOPHY and PLAY based on scroll steps

    setTimeout(() => {
      if (step >= 2 && philosophyFlipRef.current) {
        philosophyFlipRef.current.triggerFlip();
      }
    }, 200);

    setTimeout(() => {
      if (step >= 3 && playFlipRef.current) {
        playFlipRef.current.triggerFlip();
      }
    }, 400);
  };

  // Trigger flipping animations when visibleColumns changes
  useEffect(() => {
    if (isInitialized && visibleColumns >= 1) {
      // Trigger PSYCHOLOGY when first column becomes visible (step 1)
      if (visibleColumns >= 1 && psychologyFlipRef.current && !triggeredColumns.has(1)) {
        setTimeout(() => {
          psychologyFlipRef.current.triggerFlip();
          setTriggeredColumns(prev => new Set(prev).add(1));
        }, 200);
      }

      // Trigger PHILOSOPHY when second column becomes visible (step 2)
      if (visibleColumns >= 2 && philosophyFlipRef.current && !triggeredColumns.has(2)) {
        setTimeout(() => {
          philosophyFlipRef.current.triggerFlip();
          setTriggeredColumns(prev => new Set(prev).add(2));
        }, 400);
      }

      // Trigger PLAY when third column becomes visible (step 3)
      if (visibleColumns >= 3 && playFlipRef.current && !triggeredColumns.has(3)) {
        setTimeout(() => {
          playFlipRef.current.triggerFlip();
          setTriggeredColumns(prev => new Set(prev).add(3));
        }, 600);
      }
    }
  }, [visibleColumns, isInitialized, triggeredColumns]);

  // Reset triggered columns when entering slide 4
  useEffect(() => {
    if (isInitialized && currentSection === 3) {
      // Reset triggered columns when entering slide 4
      setTriggeredColumns(new Set());
    }
  }, [currentSection, isInitialized]);

  // Initialize component with proper state to prevent flash
  useEffect(() => {
    // Set initial state immediately without transitions
    setSkipTransitions(true);
    setVisibleColumns(isScrollEnabled ? 0 : 3);

    // Enable transitions after a brief delay to prevent flash
    const timer = setTimeout(() => {
      setSkipTransitions(false);
      setIsInitialized(true);
    }, 100);

    return () => clearTimeout(timer);
  }, []);

  // Reset visible columns when isScrollEnabled changes
  useEffect(() => {
    if (!isInitialized) return; // Don't run until initialized

    setSkipTransitions(true); // Disable transitions during state change

    if (!isScrollEnabled) {
      setVisibleColumns(6);
      if (onAllColumnsVisible) {
        onAllColumnsVisible();
      }
    } else {
      setVisibleColumns(0); // Start with no columns when scroll effect is enabled
      // Set initial scroll position to match step 0
      const container = containerRef.current;
      if (container) {
        container.scrollTop = 0; // Step 0 position
      }
    }

    // Re-enable transitions after state change
    setTimeout(() => {
      setSkipTransitions(false);
    }, 50);
  }, [isScrollEnabled, onAllColumnsVisible, isInitialized]);

  // Reset to initial state when entering slide 4 (currentSection === 3)
  useEffect(() => {
    if (!isInitialized) return;

    if (currentSection === 3 && isScrollEnabled) {
      // Reset to initial state when entering slide 4
      setSkipTransitions(true);
      setVisibleColumns(0);

      // Set initial scroll position
      const container = containerRef.current;
      if (container) {
        container.scrollTop = 0; // Step 0 position
      }

      // Re-enable transitions after reset
      setTimeout(() => {
        setSkipTransitions(false);
      }, 100);
    }
  }, [currentSection, isScrollEnabled, isInitialized]);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    // If scroll effect is disabled, don't add wheel listeners
    if (!isScrollEnabled) {
      return;
    }

    let wheelDelta = 0;
    let wheelTimer = null;
    let currentStep = 0; // 0, 1, 2, 3 for each column reveal step (start from 0)

    const smoothScrollToStep = (step, skipAnimation = false) => {
      if (isScrollingRef.current) return;
      isScrollingRef.current = true;

      const scrollHeight = container.scrollHeight;
      const containerHeight = container.clientHeight;
      const maxScroll = scrollHeight - containerHeight;

      // Define precise scroll positions for each step
      const scrollPositions = [
        0,                    // Step 0: No columns visible
        maxScroll * 0.2,      // Step 1: First column
        maxScroll * 0.45,     // Step 2: Second column  
        maxScroll * 0.7,      // Step 3: Third column
        maxScroll             // Step 4: Complete (triggers next slide)
      ];

      const targetScroll = scrollPositions[step] || 0;

      // Update state immediately and skip animation if requested
      if (skipAnimation || step === 0) {
        setSkipTransitions(true);
        container.scrollTop = targetScroll;
        setVisibleColumns(step);
        currentStep = step;
        isScrollingRef.current = false;

        // Re-enable transitions after a brief moment
        setTimeout(() => {
          setSkipTransitions(false);
        }, 50);

        // Notify parent when all columns are visible
        if (step === 3 && onAllColumnsVisible) {
          onAllColumnsVisible();
        }

        return;
      }

      // Smooth scroll animation using requestAnimationFrame
      const startScroll = container.scrollTop;
      const distance = targetScroll - startScroll;
      const duration = 800; // 800ms for smooth animation
      const startTime = performance.now();

      const animateScroll = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Easing function for smooth animation (easeInOutCubic)
        const easeProgress = progress < 0.5
          ? 4 * progress * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 3) / 2;

        container.scrollTop = startScroll + (distance * easeProgress);

        if (progress < 1) {
          requestAnimationFrame(animateScroll);
        } else {
          isScrollingRef.current = false;

          // Update visible columns based on step
          setVisibleColumns(step);
          currentStep = step;

          // Notify parent when all columns are visible
          if (step === 3 && onAllColumnsVisible) {
            onAllColumnsVisible();
          }

          // Auto-advance to next slide when reaching step 4
          if (step >= 4 && currentSection === 3) {
            setTimeout(() => {
              // Double check we're still on slide 4 before advancing
              if (window.gotoNextSlide && currentSection === 3) {
                window.gotoNextSlide();
              }
            }, 300);
          }
        }
      };

      requestAnimationFrame(animateScroll);
    };

    const handleWheel = (e) => {
      e.preventDefault();

      if (isScrollingRef.current) return;

      // Accumulate wheel delta
      wheelDelta += e.deltaY;

      // Clear existing timer
      if (wheelTimer) {
        clearTimeout(wheelTimer);
      }

      // Wait for wheel events to settle
      wheelTimer = setTimeout(() => {
        if (Math.abs(wheelDelta) > 30) { // Lower threshold for more responsive
          if (wheelDelta > 0) {
            // Scroll down - next step
            const nextStep = Math.min(currentStep + 1, 4);
            smoothScrollToStep(nextStep);
          } else {
            // Scroll up - previous step or go to previous slide
            if (currentStep === 0) {
              // At the beginning (step 0), go to previous slide
              if (window.gotoPrevSlide) {
                window.gotoPrevSlide();
              }
            } else {
              const prevStep = Math.max(currentStep - 1, 0);
              smoothScrollToStep(prevStep);
            }
          }
        }
        wheelDelta = 0; // Reset delta
      }, 5); // Very short delay
    };

    container.addEventListener('wheel', handleWheel, { passive: false });

    return () => {
      container.removeEventListener('wheel', handleWheel);
      if (wheelTimer) clearTimeout(wheelTimer);
      if (scrollTimeoutRef.current) clearTimeout(scrollTimeoutRef.current);
    };
  }, [onAllColumnsVisible, isScrollEnabled]);

  return (
    <div
      ref={containerRef}
      className={styles.scrollRevealContainer}
      style={{
        height: '100vh',
        overflowY: 'auto',
        overflowX: 'hidden'
      }}
    >
      <div style={{ height: '200vh', position: 'relative' }}>
        <div className={styles.featuresContainer} style={{
          position: 'sticky',
          top: 0,
          height: '100vh',
          display: 'flex',
          flexDirection: 'column',
          justifyContent: 'center'
        }}>
          {/* Top text - always visible */}
          <div
            className={styles.featuresTopText}
            style={{
              opacity: 1,
              transform: 'translateY(0)',
              marginBottom: '40px',
              textAlign: 'center'
            }}
          >
            <p className={styles.heroParagraph} style={{
              fontFamily: '"satoshi", sans-serif',
              fontSize: '14px',
              fontWeight: '500',
              letterSpacing: '1px',
              color: '#888888'
            }}>
              Together, they form the alchemy of becoming ‚Äîwhere thought becomes design, then design becomes destiny.
            </p>
          </div>

          <div className={styles.threeColumnGrid} style={{ marginBottom: 0 }}>
            <div
              ref={el => columnsRef.current[0] = el}
              className={`${styles.gridColumn} ${!isInitialized ? styles.gridColumnInitial : ''}`}
              style={{
                opacity: visibleColumns >= 1 ? 1 : 0,
                transform: visibleColumns >= 1 ? 'translateX(0)' : 'translateX(100px)',
                transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
              }}
            >
              <div className={styles.columnTitle}>
                <h3 style={{
                  fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                  fontSize: '26px',
                  color: '#00e87b',
                  fontWeight: 'normal',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                  margin: 0
                }}>
                  PSYCHOLOGY
                </h3>
              </div>
              <div className={styles.textContent}>
                <p className={styles.heroParagraph} style={{
                  fontFamily: '"satoshi", sans-serif',
                  fontSize: '14px',
                  fontWeight: '500',
                  letterSpacing: '1px',
                  color: '#888888'
                }}>
                  Beyond reflection, truth bends and flows
                  The self you design is the self that grows.
                </p>
              </div>
              <div className={styles.imageContent}>
                <Image
                  src={lifeidesignsvg}
                  width={200}
                  height={200}
                  alt="Life i Design Game"
                  className={styles.heroImageContent}
                />
              </div>
            </div>

            <div
              ref={el => columnsRef.current[1] = el}
              className={`${styles.gridColumn} ${!isInitialized && isScrollEnabled ? styles.gridColumnInitial : ''}`}
              style={{
                opacity: visibleColumns >= 2 ? 1 : 0,
                transform: visibleColumns >= 2 ? 'translateX(0)' : 'translateX(100px)',
                transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
              }}
            >
              <div className={styles.columnTitle}>
                <h3 style={{
                  fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                  fontSize: '26px',
                  color: '#00e87b',
                  fontWeight: 'normal',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                  margin: 0
                }}>
                  PHILOSOPHY
                </h3>
              </div>
              <div className={styles.textContent}>
                <p className={styles.heroParagraph} style={{
                  fontFamily: '"satoshi", sans-serif',
                  fontSize: '14px',
                  fontWeight: '500',
                  letterSpacing: '1px',
                  color: '#888888'
                }}>
                  Know thy loops, break the chain,
                  Rewire the mind, redesign the game.
                </p>
              </div>
              <div className={styles.imageContent}>
                <Image
                  src={lifeidesignsvg}
                  width={200}
                  height={200}
                  alt="Life i Design Game"
                  className={styles.heroImageContent}
                />
              </div>
            </div>

            <div
              ref={el => columnsRef.current[2] = el}
              className={`${styles.gridColumn} ${!isInitialized && isScrollEnabled ? styles.gridColumnInitial : ''}`}
              style={{
                opacity: visibleColumns >= 3 ? 1 : 0,
                transform: visibleColumns >= 3 ? 'translateX(0)' : 'translateX(100px)',
                transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.4s'
              }}
            >
              <div className={styles.columnTitle}>
                <h3 style={{
                  fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                  fontSize: '26px',
                  color: '#00e87b',
                  fontWeight: 'normal',
                  textTransform: 'uppercase',
                  letterSpacing: '1px',
                  margin: 0
                }}>
                  PLAY
                </h3>
              </div>
              <div className={styles.textContent}>
                <p className={styles.heroParagraph} style={{
                  fontFamily: '"satoshi", sans-serif',
                  fontSize: '14px',
                  fontWeight: '500',
                  letterSpacing: '1px',
                  color: '#888888'
                }}>
                  Fall, rise, and play unbound,
                  Where curiosity leads, wonder's found.
                </p>
              </div>
              <div className={styles.imageContent}>
                <Image
                  src={lifeidesignsvg}
                  width={200}
                  height={200}
                  alt="Life i Design Game"
                  className={styles.heroImageContent}
                />
              </div>
            </div>
          </div>

          {/* Progress Indicator Line */}
          <div className={styles.columnProgressIndicator}>
            <div className={styles.progressLine}>
              <div
                className={styles.progressSegment}
                style={{
                  opacity: visibleColumns >= 1 ? 1 : 0,
                  transform: visibleColumns >= 1 ? 'scale(1)' : 'scale(0)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
                }}
              >
                <div
                  className={`${styles.progressNumber} ${visibleColumns >= 1 ? styles.progressActive : ''}`}
                  style={{
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease'
                  }}
                >
                </div>
              </div>
              <div
                className={`${styles.progressConnector} ${visibleColumns >= 2 ? styles.progressActive : ''}`}
                style={{
                  opacity: visibleColumns >= 2 ? 1 : 0,
                  transform: visibleColumns >= 2 ? 'scaleX(1)' : 'scaleX(0)',
                  transformOrigin: 'left',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.1s'
                }}
              ></div>
              <div
                className={styles.progressSegment}
                style={{
                  opacity: visibleColumns >= 2 ? 1 : 0,
                  transform: visibleColumns >= 2 ? 'scale(1)' : 'scale(0)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
                }}
              >
                <div
                  className={`${styles.progressNumber} ${visibleColumns >= 2 ? styles.progressActive : ''}`}
                  style={{
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.2s'
                  }}
                >
                </div>
              </div>
              <div
                className={`${styles.progressConnector} ${visibleColumns >= 3 ? styles.progressActive : ''}`}
                style={{
                  opacity: visibleColumns >= 3 ? 1 : 0,
                  transform: visibleColumns >= 3 ? 'scaleX(1)' : 'scaleX(0)',
                  transformOrigin: 'left',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.3s'
                }}
              ></div>
              <div
                className={styles.progressSegment}
                style={{
                  opacity: visibleColumns >= 3 ? 1 : 0,
                  transform: visibleColumns >= 3 ? 'scale(1)' : 'scale(0)',
                  transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.4s'
                }}
              >
                <div
                  className={`${styles.progressNumber} ${visibleColumns >= 3 ? styles.progressActive : ''}`}
                  style={{
                    transition: skipTransitions || !isInitialized ? 'none' : 'all 0.6s ease 0.4s'
                  }}
                >
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

// Slide12DesignModesCarousel component with overlapping cards subscroll
const Slide12DesignModesCarousel = ({ onAllCardsVisible, onNextSection, onPrevSection, onGroupChange, currentSection, isScrollEnabled = true }) => {
  const containerRef = useRef(null);
  const cardsStackRef = useRef(null);
  const [activeCard, setActiveCard] = useState(0);
  const [isInitialized, setIsInitialized] = useState(false);
  const isScrollingRef = useRef(false);

  const slide12CardsData = [
    {
      id: 0,
      title: "Pre-Game",
      description: "You map your life from start to end,to see what broke ‚Äî and what will bend.",
      color: "#ff6b6b"
    },
    {
      id: 1,
      title: "End-Game",
      description: "You lose, you learn, you burn, you mend,your loss becomes your spark again..",
      color: "#4ecdc4"
    },
    {
      id: 2,
      title: "Me-game",
      description: "Be the engine of your dawn,and the anchor through the storm.",
      color: "#45b7d1"
    },
    {
      id: 3,
      title: "Mirror Mode",
      description: "You face your truth, your flaws, your gleam,to see which self still runs the dream.",
      color: "#f7b731"
    },
    {
      id: 4,
      title: "NPC Mode",
      description: "You spend your wants, your masks unmade,to find the worth that won't degrade.",
      color: "#5f27cd"
    },
    {
      id: 5,
      title: "Monk Mode",
      description: "You strip it all, till nothing's left,and find your power in what's bereft.",
      color: "#00d2d3"
    },
    {
      id: 6,
      title: "Everyday Mode",
      description: "You track your flow, refine your way,each small design becomes your day.",
      color: "#ff9ff3"
    },
    {
      id: 7,
      title: "Ghost Mode",
      description: "You turn off light, the noise, the feed,to hear the pulse your spirit leads.",
      color: "#54a0ff"
    },
    {
      id: 8,
      title: "Underground Mode",
      description: "You break the mold, confront the clay,the self remade begins to stay.",
      color: "#5f27cd"
    },
    {
      id: 9,
      title: "Human Mode",
      description: "You face the dark, accept the scar,the broken makes you who you Human are.",
      color: "#ff6348"
    },
    {
      id: 10,
      title: "Hero Mode",
      description: "Through many masks, one flame you stoke,the myth made whole becomes your Hero cloak.",
      color: "#2ed573"
    },
    {
      id: 11,
      title: "God Mode",
      description: "Beyond all form, beyond facade,you breathe as light, you live as God.",
      color: "#ffa502"
    }
  ];

  // Animate cards to show stacking effect with groups of 3
  const animateToCard = useCallback((targetIndex) => {
    setActiveCard(targetIndex);

    // Calculate which group we're in (0, 1, 2, 3 for 12 cards)
    const currentGroup = Math.floor(targetIndex / 3);
    const positionInGroup = targetIndex % 3;

    // Notify parent component about group change
    if (onGroupChange) {
      onGroupChange(currentGroup);
    }

    // Animate each card based on its relationship to the active card
    const cardWrappers = cardsStackRef.current?.querySelectorAll(`.${styles.slide12CardWrapper}`);
    if (!cardWrappers) return;

    cardWrappers.forEach((wrapper, index) => {
      const card = wrapper.querySelector(`.${styles.slide12OverlappingCard}`);
      if (!card) return;

      const cardGroup = Math.floor(index / 3);
      const cardPositionInGroup = index % 3;

      if (cardGroup < currentGroup) {
        // Previous groups - slide up and out
        const yOffset = -window.innerHeight;
        wrapper.style.transform = `translateY(${yOffset}px)`;
        card.style.transform = `rotateX(0deg) scale(0.8)`;
        card.style.opacity = '0';
        card.style.zIndex = index + 1;
        card.classList.remove(styles.slide12CardActive);
      } else if (cardGroup === currentGroup) {
        // Current group - show stacking effect with visible titles
        if (cardPositionInGroup <= positionInGroup) {
          // Cards that should be visible/active in current group - no scaling, keep full size
          const rotationX = cardPositionInGroup === positionInGroup ? 0 : 0; // No rotation for cleaner look
          const yOffset = cardPositionInGroup * 80; // Increased offset to show titles and separator lines

          wrapper.style.transform = `translateY(${yOffset}px)`;
          card.style.transform = `rotateX(${rotationX}deg) scale(1)`; // Always scale 1
          card.style.opacity = '1';
          card.style.zIndex = index + 1;

          // Add active class to current card
          if (index === targetIndex) {
            card.classList.add(styles.slide12CardActive);
          } else {
            card.classList.remove(styles.slide12CardActive);
          }
        } else {
          // Cards in current group that haven't appeared yet
          const yOffset = window.innerHeight;
          wrapper.style.transform = `translateY(${yOffset}px)`;
          card.style.transform = `rotateX(0deg) scale(1)`; // Keep full size even when hidden
          card.style.opacity = '0.3';
          card.style.zIndex = index + 1;
          card.classList.remove(styles.slide12CardActive);
        }
      } else {
        // Future groups - keep hidden below
        const yOffset = window.innerHeight;
        wrapper.style.transform = `translateY(${yOffset}px)`;
        card.style.transform = `rotateX(0deg) scale(0.8)`;
        card.style.opacity = '0';
        card.style.zIndex = index + 1;
        card.classList.remove(styles.slide12CardActive);
      }
    });
  }, [onGroupChange]);

  // Initialize component
  useEffect(() => {
    setIsInitialized(true);
    // Small delay to ensure DOM is ready
    const timer = setTimeout(() => {
      animateToCard(0); // Start with first card active
    }, 100);

    return () => clearTimeout(timer);
  }, []);

  // Reset when entering slide 12 (currentSection === 11)
  useEffect(() => {
    if (!isInitialized) return;

    if (currentSection === 11 && isScrollEnabled) {
      animateToCard(0);
    }
  }, [currentSection, isScrollEnabled, isInitialized]);

  // Handle subscroll functionality
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    // If scroll effect is disabled, don't add wheel listeners
    if (!isScrollEnabled) {
      return;
    }

    let wheelDelta = 0;
    let wheelTimer = null;

    const handleWheel = (e) => {
      if (isScrollingRef.current) return;

      e.preventDefault();
      e.stopPropagation();

      wheelDelta += e.deltaY;

      clearTimeout(wheelTimer);
      wheelTimer = setTimeout(() => {
        if (Math.abs(wheelDelta) > 100) {
          if (wheelDelta > 0 && activeCard < slide12CardsData.length - 1) {
            // Scroll down (next card)
            animateToCard(activeCard + 1);
          } else if (wheelDelta < 0 && activeCard > 0) {
            // Scroll up (previous card)
            animateToCard(activeCard - 1);
          } else if (wheelDelta < 0 && activeCard === 0) {
            // At first card, trigger previous section
            setTimeout(() => {
              if (window.gotoPrevSlide) {
                window.gotoPrevSlide();
              }
            }, 100);
          } else if (wheelDelta > 0 && activeCard === slide12CardsData.length - 1) {
            // At last card, trigger next section
            if (onAllCardsVisible) {
              onAllCardsVisible();
            }
            // Trigger main scroll to next section
            setTimeout(() => {
              if (window.gotoNextSlide) {
                window.gotoNextSlide();
              }
            }, 100);
          }
        }
        wheelDelta = 0;
      }, 100);
    };

    // Add event listener with capture to ensure it gets the event first
    container.addEventListener('wheel', handleWheel, { passive: false, capture: true });

    return () => {
      container.removeEventListener('wheel', handleWheel, { capture: true });
      clearTimeout(wheelTimer);
    };
  }, [isScrollEnabled, onAllCardsVisible, onNextSection, onPrevSection, isInitialized, slide12CardsData.length, activeCard, animateToCard]);

  return (
    <div className={styles.slide12OverlappingCardsContainer} ref={containerRef}>
      <div className={styles.slide12CardsStack} ref={cardsStackRef}>
        {slide12CardsData.map((card, index) => (
          <div
            key={card.id}
            className={styles.slide12CardWrapper}
            style={{
              transform: `translateY(${index * 80}px)`,
              zIndex: index + 1
            }}
          >
            <div
              className={`${styles.slide12OverlappingCard} ${activeCard === index ? styles.slide12CardActive : ''}`}
              style={{
                '--card-color': card.color,
                background: '#000000',
                cursor: 'pointer'
              }}
              onClick={(e) => {
                e.stopPropagation();
                console.log('Card clicked:', index, card.title);
                // Auto-scroll to this card when clicked
                if (index !== activeCard) {
                  animateToCard(index);
                }
              }}
            >
              <div className={styles.slide12CardContent}>
                <h3
                  className={styles.slide12CardTitle}
                  style={{
                    cursor: 'pointer',
                    padding: '10px',
                    margin: '0 -10px 0 -10px'
                  }}
                >
                  <span style={{
                    fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                    fontSize: '26px',
                    color: '#00e87b',
                    fontWeight: 'normal',
                    textTransform: 'uppercase',
                    letterSpacing: '1px'
                  }}>
                    {card.title}
                  </span>
                </h3>
                <div className={styles.slide12CardTitleDivider}></div>
                <p className={styles.slide12CardDescription}>{card.description}</p>
                <div className={styles.slide12CardNumber}>{String(index + 1).padStart(2, '0')}</div>
              </div>
            </div>
          </div>
        ))}
      </div>

      {/* Progress indicator */}
      <div className={styles.slide12ProgressIndicator}>
        <div className={styles.slide12ProgressBar}>
          <div
            className={styles.slide12ProgressFill}
            style={{
              width: `${((activeCard + 1) / slide12CardsData.length) * 100}%`
            }}
          />
        </div>
        <span className={styles.slide12ProgressText}>
          {activeCard + 1} / {slide12CardsData.length}
        </span>
      </div>
    </div>
  );
};

// Slide13DesignModesCarousel component - EXACT replica of slide 12
const Slide13DesignModesCarousel = ({ onAllCardsVisible, onNextSection, onPrevSection, onGroupChange, currentSection, isScrollEnabled = true }) => {
  const containerRef = useRef(null);
  const cardsStackRef = useRef(null);
  const [activeCard, setActiveCard] = useState(0);
  const [isInitialized, setIsInitialized] = useState(false);
  const isScrollingRef = useRef(false);

  const slide13CardsData = [
    {
      id: 0,
      title: "Accessories",
      description: "Tools of truth in mortal hand,turn will to work, and thought to land.",
      color: "#ff6b6b"
    },
    {
      id: 1,
      title: "Journals",
      description: "Ink the truth your mirrors say,thoughts take form, then find their way.",
      color: "#4ecdc4"
    },
    {
      id: 2,
      title: "Games",
      description: "Chance and choice in sacred spin, where play reveals the worlds within.",
      color: "#45b7d1"
    },
    {
      id: 3,
      title: "App ",
      description: "Tap your path, your pulse, your plan,evolve each move ‚Äî become the span.",
      color: "#f7b731"
    },
    {
      id: 4,
      title: "System ",
      description: "Build your base, design your core,your life now runs like never before.",
      color: "#5f27cd"
    },
    {
      id: 5,
      title: "Tools",
      description: "Sculpt the spark, command the air,design turns dream to something rare.",
      color: "#00d2d3"
    },
    {
      id: 6,
      title: "Stay",
      description: "A haven built for soul repair,where silence breathes and minds prepare..",
      color: "#ff9ff3"
    },
    {
      id: 7,
      title: "Food",
      description: "Fuel for greatness, calm, and fire,each bite refines your true desire.",
      color: "#54a0ff"
    },
    {
      id: 8,
      title: "Training",
      description: "Flesh and focus, breath and bone,the body becomes the self you own.",
      color: "#5f27cd"
    },
    {
      id: 9,
      title: "Strategy",
      description: "We map your moves, but you decide,the plan adapts, the path is wide.",
      color: "#ff6348"
    },
    {
      id: 10,
      title: "Accountability",
      description: "No place to hide, no mask to keep,your word's the vow your actions reap.",
      color: "#2ed573"
    },
    {
      id: 11,
      title: "Guidance",
      description: "We break your fall, then lift your stance,to turn each wound into advance.",
      color: "#ffa502"
    }
  ];

  // Animate cards to show stacking effect with groups of 3
  const animateToCard = useCallback((targetIndex) => {
    setActiveCard(targetIndex);

    // Calculate which group we're in (0, 1, 2, 3 for 12 cards)
    const currentGroup = Math.floor(targetIndex / 3);
    const positionInGroup = targetIndex % 3;

    // Notify parent component about group change
    if (onGroupChange) {
      onGroupChange(currentGroup);
    }

    // Animate each card based on its relationship to the active card
    const cardWrappers = cardsStackRef.current?.querySelectorAll(`.${styles.slide12CardWrapper}`);
    if (!cardWrappers) return;

    cardWrappers.forEach((wrapper, index) => {
      const card = wrapper.querySelector(`.${styles.slide12OverlappingCard}`);
      if (!card) return;

      const cardGroup = Math.floor(index / 3);
      const cardPositionInGroup = index % 3;

      if (cardGroup < currentGroup) {
        // Previous groups - slide up and out
        const yOffset = -window.innerHeight;
        wrapper.style.transform = `translateY(${yOffset}px)`;
        card.style.transform = `rotateX(0deg) scale(0.8)`;
        card.style.opacity = '0';
        card.style.zIndex = index + 1;
        card.classList.remove(styles.slide12CardActive);
      } else if (cardGroup === currentGroup) {
        // Current group - show stacking effect with visible titles
        if (cardPositionInGroup <= positionInGroup) {
          // Cards that should be visible/active in current group - no scaling, keep full size
          const rotationX = cardPositionInGroup === positionInGroup ? 0 : 0; // No rotation for cleaner look
          const yOffset = cardPositionInGroup * 80; // Increased offset to show titles and separator lines

          wrapper.style.transform = `translateY(${yOffset}px)`;
          card.style.transform = `rotateX(${rotationX}deg) scale(1)`; // Always scale 1
          card.style.opacity = '1';
          card.style.zIndex = index + 1;

          // Add active class to current card
          if (index === targetIndex) {
            card.classList.add(styles.slide12CardActive);
          } else {
            card.classList.remove(styles.slide12CardActive);
          }
        } else {
          // Cards in current group that haven't appeared yet
          const yOffset = window.innerHeight;
          wrapper.style.transform = `translateY(${yOffset}px)`;
          card.style.transform = `rotateX(0deg) scale(1)`; // Keep full size even when hidden
          card.style.opacity = '0.3';
          card.style.zIndex = index + 1;
          card.classList.remove(styles.slide12CardActive);
        }
      } else {
        // Future groups - keep hidden below
        const yOffset = window.innerHeight;
        wrapper.style.transform = `translateY(${yOffset}px)`;
        card.style.transform = `rotateX(0deg) scale(0.8)`;
        card.style.opacity = '0';
        card.style.zIndex = index + 1;
        card.classList.remove(styles.slide12CardActive);
      }
    });
  }, [onGroupChange]);

  // Initialize component
  useEffect(() => {
    setIsInitialized(true);
    // Small delay to ensure DOM is ready
    const timer = setTimeout(() => {
      animateToCard(0); // Start with first card active
    }, 100);

    return () => clearTimeout(timer);
  }, []);

  // Reset when entering slide 13 (currentSection === 12)
  useEffect(() => {
    if (!isInitialized) return;

    if (currentSection === 12 && isScrollEnabled) {
      animateToCard(0);
    }
  }, [currentSection, isScrollEnabled, isInitialized]);

  // Handle subscroll functionality
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    // If scroll effect is disabled, don't add wheel listeners
    if (!isScrollEnabled) {
      return;
    }

    let wheelDelta = 0;
    let wheelTimer = null;

    const handleWheel = (e) => {
      if (isScrollingRef.current) return;

      e.preventDefault();
      e.stopPropagation();

      wheelDelta += e.deltaY;

      clearTimeout(wheelTimer);
      wheelTimer = setTimeout(() => {
        if (Math.abs(wheelDelta) > 100) {
          if (wheelDelta > 0 && activeCard < slide13CardsData.length - 1) {
            // Scroll down (next card)
            animateToCard(activeCard + 1);
          } else if (wheelDelta < 0 && activeCard > 0) {
            // Scroll up (previous card)
            animateToCard(activeCard - 1);
          } else if (wheelDelta < 0 && activeCard === 0) {
            // At first card, trigger previous section
            setTimeout(() => {
              if (window.gotoPrevSlide) {
                window.gotoPrevSlide();
              }
            }, 100);
          } else if (wheelDelta > 0 && activeCard === slide13CardsData.length - 1) {
            // At last card, trigger next section
            if (onAllCardsVisible) {
              onAllCardsVisible();
            }
            // Trigger main scroll to next section
            setTimeout(() => {
              if (window.gotoNextSlide) {
                window.gotoNextSlide();
              }
            }, 100);
          }
        }
        wheelDelta = 0;
      }, 100);
    };

    // Add event listener with capture to ensure it gets the event first
    container.addEventListener('wheel', handleWheel, { passive: false, capture: true });

    return () => {
      container.removeEventListener('wheel', handleWheel, { capture: true });
      clearTimeout(wheelTimer);
    };
  }, [isScrollEnabled, onAllCardsVisible, onNextSection, onPrevSection, isInitialized, slide13CardsData.length, activeCard, animateToCard]);

  return (
    <div className={styles.slide12OverlappingCardsContainer} ref={containerRef}>
      <div className={styles.slide12CardsStack} ref={cardsStackRef}>
        {slide13CardsData.map((card, index) => (
          <div
            key={card.id}
            className={styles.slide12CardWrapper}
            style={{
              transform: `translateY(${index * 80}px)`,
              zIndex: index + 1
            }}
          >
            <div
              className={`${styles.slide12OverlappingCard} ${activeCard === index ? styles.slide12CardActive : ''}`}
              style={{
                '--card-color': card.color,
                background: '#000000',
                cursor: 'pointer'
              }}
              onClick={(e) => {
                e.stopPropagation();
                console.log('Card clicked:', index, card.title);
                // Auto-scroll to this card when clicked
                if (index !== activeCard) {
                  animateToCard(index);
                }
              }}
            >
              <div className={styles.slide12CardContent}>
                <h3 className={styles.slide12CardTitle}>
                  <span style={{
                    fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                    fontSize: '26px',
                    color: '#00e87b',
                    fontWeight: 'normal',
                    textTransform: 'uppercase',
                    letterSpacing: '1px'
                  }}>
                    {card.title}
                  </span>
                </h3>
                <div className={styles.slide12CardTitleDivider}></div>
                <p className={styles.slide12CardDescription}>{card.description}</p>
                <div className={styles.slide12CardNumber}>{String(index + 1).padStart(2, '0')}</div>
              </div>
            </div>
          </div>
        ))}
      </div>

      {/* Progress indicator */}
      <div className={styles.slide12ProgressIndicator}>
        <div className={styles.slide12ProgressBar}>
          <div
            className={styles.slide12ProgressFill}
            style={{
              width: `${((activeCard + 1) / slide13CardsData.length) * 100}%`
            }}
          />
        </div>
        <span className={styles.slide12ProgressText}>
          {activeCard + 1} / {slide13CardsData.length}
        </span>
      </div>
    </div>
  );
};

// Slide15GameModesCarousel component - EXACT replica of GameEcosystemCarousel (slide 14)
const Slide15GameModesCarousel = ({ onAllSlidesVisible, onNextSection, onPrevSection, currentSection, isScrollEnabled = true }) => {
  const containerRef = useRef(null);
  const [currentSlide, setCurrentSlide] = useState(0);
  const [skipTransitions, setSkipTransitions] = useState(true);
  const [isInitialized, setIsInitialized] = useState(false);
  const isScrollingRef = useRef(false);
  const currentStepRef = useRef(0);

  const gameModesData = [
    {
      id: 0,
      title: "EPiCENTRE ‚Äî The Retreat of Return",
      description: "The foundational quest where you architect your identity, values, and vision. This is where transformation begins - by designing the person you're becoming.",
      liberationMove: "Players can book 48-hour, 1-week, or 1-month & Quarterly immersions.",
      launchDate: "Q1 2025",
      color: "#00e87b",
      bgImage: "linear-gradient(135deg, #00e87b 0%, #00a86b 100%)"
    },
    {
      id: 1,
      title: "THEATRE OF THE INVERSE ‚Äî Where the Mask Meets the Mirror",
      description: "Navigate the space between who you were and who you're becoming. Learn to drift with purpose through uncertainty and emerge stronger.",
      liberationMove: " Serves as the final Demo Day for graduating cohorts.",
      launchDate: "Q2 2025",
      color: "#ff6b6b",
      bgImage: "linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%)"
    },
    {
      id: 2,
      title: "LIBERATION CAPITAL ‚Äî The Fund of Becoming",
      description: "Document and design your life story in real-time. Turn your experiences into a masterpiece of intentional living and conscious creation.",
      liberationMove: "Players can apply for LIFEiDESIGN scholarships or post-graduation funding.",
      launchDate: "Q3 2025",
      color: "#4ecdc4",
      bgImage: "linear-gradient(135deg, #4ecdc4 0%, #26d0ce 100%)"
    },
    {
      id: 3,
      title: "BIG¬π ‚Äî Silent Tourism",
      description: "The integration quest where mind, body, and soul align. Experience life through all senses while maintaining your designed identity.",
      liberationMove: "Open to players and non-players alike.",
      launchDate: "Q4 2025",
      color: "#f7b731",
      bgImage: "linear-gradient(135deg, #f7b731 0%, #f39c12 100%)"
    },
    {
      id: 4,
      title: "SUGAR¬∑PUNK ‚Äî The Living Neighbourhood",
      description: "A gated, sustainable community for post-game living ‚Äî where design meets ecology. Every home produces its own food, energy, and resources. A sandbox for those who choose self-sufficiency as their final game.",
      liberationMove: "Residences & Plots are offered first to LIFEiDESIGN graduates.",
      launchDate: "Q1 2026",
      color: "#5f27cd",
      bgImage: "linear-gradient(135deg, #5f27cd 0%, #341f97 100%)"
    }
  ];

  // Initialize component
  useEffect(() => {
    setSkipTransitions(true);
    setCurrentSlide(0);

    const timer = setTimeout(() => {
      setSkipTransitions(false);
      setIsInitialized(true);
    }, 100);

    return () => clearTimeout(timer);
  }, []);

  // Reset when entering slide 15 (currentSection === 14)
  useEffect(() => {
    if (!isInitialized) return;

    if (currentSection === 14 && isScrollEnabled) {
      setSkipTransitions(true);
      setCurrentSlide(0);
      currentStepRef.current = 0;

      const container = containerRef.current;
      if (container) {
        container.scrollLeft = 0;
      }

      setTimeout(() => {
        setSkipTransitions(false);
      }, 100);
    }
  }, [currentSection, isScrollEnabled, isInitialized]);

  // Handle subscroll functionality
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    // If scroll effect is disabled, don't add wheel listeners
    if (!isScrollEnabled) {
      return;
    }

    let wheelDelta = 0;
    let wheelTimer = null;

    const smoothScrollToSlide = (slideIndex, skipAnimation = false) => {
      if (isScrollingRef.current) return;
      isScrollingRef.current = true;

      const wrapper = container.querySelector(`.${styles.carouselWrapper}`);
      if (!wrapper) {
        isScrollingRef.current = false;
        return;
      }

      const slideWidth = container.clientWidth;
      // Reverse direction: slide from right to left
      // Start from the rightmost position and move left
      const totalSlides = gameModesData.length;
      const maxTransform = -((totalSlides - 1) * slideWidth);
      const targetTransform = maxTransform + (slideIndex * slideWidth);

      // Update state immediately
      setCurrentSlide(slideIndex);
      currentStepRef.current = slideIndex;

      if (skipAnimation) {
        setSkipTransitions(true);
        wrapper.style.transition = 'none';
        wrapper.style.transform = `translateX(${targetTransform}px)`;
        isScrollingRef.current = false;

        setTimeout(() => {
          setSkipTransitions(false);
          wrapper.style.transition = 'transform 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
        }, 50);

        // Notify parent when all slides are visible
        if (slideIndex === gameModesData.length - 1 && onAllSlidesVisible) {
          onAllSlidesVisible();
        }
        return;
      }

      // Smooth scroll animation using requestAnimationFrame
      wrapper.style.transition = 'none'; // Disable CSS transitions during animation

      const currentTransform = wrapper.style.transform ?
        parseFloat(wrapper.style.transform.match(/translateX\(([^)]+)px\)/)?.[1] || 0) : 0;
      const distance = targetTransform - currentTransform;
      const duration = 800; // 800ms for smooth animation
      const startTime = performance.now();

      const easeInOutCubic = (t) => {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      };

      const animateScroll = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easedProgress = easeInOutCubic(progress);

        const newTransform = currentTransform + (distance * easedProgress);
        wrapper.style.transform = `translateX(${newTransform}px)`;

        if (progress < 1) {
          requestAnimationFrame(animateScroll);
        } else {
          wrapper.style.transition = 'transform 0.8s cubic-bezier(0.4, 0, 0.2, 1)'; // Re-enable transitions
          isScrollingRef.current = false;

          // Notify parent when all slides are visible
          if (slideIndex === gameModesData.length - 1 && onAllSlidesVisible) {
            onAllSlidesVisible();
          }
        }
      };

      requestAnimationFrame(animateScroll);
    };

    const handleWheel = (e) => {
      if (isScrollingRef.current) return;

      e.preventDefault();
      e.stopPropagation();

      wheelDelta += e.deltaY;

      clearTimeout(wheelTimer);
      wheelTimer = setTimeout(() => {
        if (Math.abs(wheelDelta) > 100) { // Increased threshold for better control
          if (wheelDelta > 0 && currentStepRef.current < gameModesData.length - 1) {
            // Scroll right (next slide)
            currentStepRef.current++;
            smoothScrollToSlide(currentStepRef.current);
          } else if (wheelDelta < 0 && currentStepRef.current > 0) {
            // Scroll left (previous slide)
            currentStepRef.current--;
            smoothScrollToSlide(currentStepRef.current);
          } else if (wheelDelta < 0 && currentStepRef.current === 0) {
            // At first slide, trigger previous section
            if (onPrevSection) {
              setTimeout(() => {
                onPrevSection();
              }, 100);
            }
          } else if (wheelDelta > 0 && currentStepRef.current === gameModesData.length - 1) {
            // At last slide, trigger next section
            if (onAllSlidesVisible) {
              onAllSlidesVisible();
            }
            // Trigger main scroll to next section
            if (onNextSection) {
              setTimeout(() => {
                onNextSection();
              }, 100);
            }
          }
        }
        wheelDelta = 0;
      }, 100); // Increased timeout for better control
    };

    // Add event listener with capture to ensure it gets the event first
    container.addEventListener('wheel', handleWheel, { passive: false, capture: true });

    // Initialize with first slide
    smoothScrollToSlide(0, true);

    return () => {
      container.removeEventListener('wheel', handleWheel, { capture: true });
      clearTimeout(wheelTimer);
    };
  }, [isScrollEnabled, onAllSlidesVisible, onNextSection, onPrevSection, isInitialized, gameModesData.length]);

  return (
    <div className={styles.gameEcosystemCarousel}>
      <div
        ref={containerRef}
        className={styles.carouselContainer}
      >
        <div className={styles.carouselWrapper}>
          {gameModesData.map((item, index) => (
            <div
              key={item.id}
              className={styles.carouselSlide}
              style={{
                background: '#000000',
                transition: skipTransitions ? 'none' : 'opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1)'
              }}
            >
              <div className={styles.slideContent}>
                <div className={styles.slideText}>
                  <h1 className={styles.slideTitle} style={{ color: item.color }}>
                    <span style={{
                      fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                      fontSize: '26px',
                      color: '#00e87b',
                      fontWeight: 'normal',
                      textTransform: 'uppercase',
                      letterSpacing: '1px'
                    }}>
                      {item.title}
                    </span>
                  </h1>
                  <p className={styles.slideDescription}>{item.description}</p>
                </div>
                
                {/* Launching and Liberation text container */}
                <div className={styles.slideTextContainer}>
                  {/* Launching text */}
                  <div className={styles.slideLaunchText}>
                    <div className={styles.textTableRow}>
                      <div className={styles.textPrefixCell}>
                        <span className={styles.launchTextPrefix}>Launching: </span>
                      </div>
                      <div className={styles.textValueCell}>
                        <span className={styles.launchTextDate}>{item.launchDate}</span>
                      </div>
                    </div>
                  </div>
                  
                  {/* Liberation text */}
                  <div className={styles.slideGreenText}>
                    <div className={styles.textTableRow}>
                      <div className={styles.textPrefixCell}>
                        <span className={styles.liberationMovePrefix}>INTEGRATION MODEL: </span>
                      </div>
                      <div className={styles.textValueCell}>
                        <span className={styles.liberationMoveText}>{item.liberationMove}</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              {/* Slide indicator */}
              <div className={styles.slideIndicator}>
                <span className={styles.slideNumber}>{String(index + 1).padStart(2, '0')}</span>
                <span className={styles.slideTotal}>/ {String(gameModesData.length).padStart(2, '0')}</span>
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Grey text and navigation dots container */}
      <div className={styles.carouselBottomSection}>
        <div className={styles.slideTopText}>
          <span className={styles.topTextLabel}>Five modes. Five paths of becoming. Each one a gateway ‚Äîfrom design to destiny.</span>
        </div>
        
      <div className={styles.carouselDots}>
        {gameModesData.map((_, index) => (
          <div
            key={index}
            className={`${styles.carouselDot} ${currentSlide === index ? styles.carouselDotActive : ''}`}
          />
        ))}
        </div>
      </div>
    </div>
  );
};

// GameEcosystemCarousel component with subscroll functionality
const GameEcosystemCarousel = ({ onAllSlidesVisible, onNextSection, onPrevSection, currentSection, isScrollEnabled = true }) => {
  const containerRef = useRef(null);
  const [currentSlide, setCurrentSlide] = useState(0);
  const [skipTransitions, setSkipTransitions] = useState(true);
  const [isInitialized, setIsInitialized] = useState(false);
  const isScrollingRef = useRef(false);

  const ecosystemData = [
    {
      id: 0,
      title: "Design Thyself",
      description: "Your initiation into self-authorship.Learn to design your habits, emotions, and choices as creative acts ‚Äî turning daily existence into a living artwork.Liberation Move: Awareness ‚Üí Alignment.",
      liberationMove: "Awareness ‚Üí Alignment",
      launchDate: "December 2025",
      color: "#00e87b",
      bgImage: "linear-gradient(135deg, #00e87b 0%, #00a86b 100%)"
    },
    {
      id: 1,
      title: "Hero's Drift",
      description: "Step into archetypes, rewrite your myth, and balance chaos with creation.This is where your personas collide ‚Äî and you learn to dance in the drift.Liberation Move: Identity ‚Üí Integration.",
      liberationMove: "identity ‚Üí integration",
      launchDate: "December 2026",
      color: "#ff6b6b",
      bgImage: "linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%)"
    },
    {
      id: 2,
      title: "LIFEoGRAPHY",
      description: "Turn memory into mythology. Chronicle your evolution through storyboards, visuals, and journals.Transform chaos into narrative coherence ‚Äî your life, written by you.Liberation Move: Reflection ‚Üí Meaning.",
      liberationMove: "reflection ‚Üí meaning",
      launchDate: "December 2027",
      color: "#4ecdc4",
      bgImage: "linear-gradient(135deg, #4ecdc4 0%, #26d0ce 100%)"
    },
    {
      id: 3,
      title: "Eat ¬∑ Pray ¬∑ Rizz",
      description: "The final act ‚Äî embodiment.Where wisdom meets flavor, devotion meets mischief, and your energy becomes transmission.Liberation Move: Mastery ‚Üí Freedom.",
      liberationMove: "mastery ‚Üí freedom",
      launchDate: "December 2028",
      color: "#f7b731",
      bgImage: "linear-gradient(135deg, #f7b731 0%, #f39c12 100%)"
    }
  ];

  // Initialize component
  useEffect(() => {
    setSkipTransitions(true);
    setCurrentSlide(0);

    const timer = setTimeout(() => {
      setSkipTransitions(false);
      setIsInitialized(true);
    }, 100);

    return () => clearTimeout(timer);
  }, []);

  // Reset when entering slide 14 (currentSection === 13)
  useEffect(() => {
    if (!isInitialized) return;

    if (currentSection === 13 && isScrollEnabled) {
      setSkipTransitions(true);
      setCurrentSlide(0);

      const container = containerRef.current;
      if (container) {
        container.scrollLeft = 0;
      }

      setTimeout(() => {
        setSkipTransitions(false);
      }, 100);
    }
  }, [currentSection, isScrollEnabled, isInitialized]);

  // Handle subscroll functionality
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    // If scroll effect is disabled, don't add wheel listeners
    if (!isScrollEnabled) {
      return;
    }

    let wheelDelta = 0;
    let wheelTimer = null;
    let currentStep = 0; // Track current step (0, 1, 2, 3)

    const smoothScrollToSlide = (slideIndex, skipAnimation = false) => {
      if (isScrollingRef.current) return;
      isScrollingRef.current = true;

      const wrapper = container.querySelector(`.${styles.carouselWrapper}`);
      if (!wrapper) {
        isScrollingRef.current = false;
        return;
      }

      const slideWidth = container.clientWidth;
      const targetTransform = -(slideIndex * slideWidth);

      // Update state immediately
      setCurrentSlide(slideIndex);
      currentStep = slideIndex;

      if (skipAnimation) {
        setSkipTransitions(true);
        wrapper.style.transition = 'none';
        wrapper.style.transform = `translateX(${targetTransform}px)`;
        isScrollingRef.current = false;

        setTimeout(() => {
          setSkipTransitions(false);
          wrapper.style.transition = 'transform 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
        }, 50);

        // Notify parent when all slides are visible
        if (slideIndex === ecosystemData.length - 1 && onAllSlidesVisible) {
          onAllSlidesVisible();
        }
        return;
      }

      // Smooth scroll animation using requestAnimationFrame
      wrapper.style.transition = 'none'; // Disable CSS transitions during animation

      const currentTransform = wrapper.style.transform ?
        parseFloat(wrapper.style.transform.match(/translateX\(([^)]+)px\)/)?.[1] || 0) : 0;
      const distance = targetTransform - currentTransform;
      const duration = 800; // 800ms for smooth animation
      const startTime = performance.now();

      const easeInOutCubic = (t) => {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      };

      const animateScroll = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const easedProgress = easeInOutCubic(progress);

        const newTransform = currentTransform + (distance * easedProgress);
        wrapper.style.transform = `translateX(${newTransform}px)`;

        if (progress < 1) {
          requestAnimationFrame(animateScroll);
        } else {
          wrapper.style.transition = 'transform 0.8s cubic-bezier(0.4, 0, 0.2, 1)'; // Re-enable transitions
          isScrollingRef.current = false;

          // Notify parent when all slides are visible
          if (slideIndex === ecosystemData.length - 1 && onAllSlidesVisible) {
            onAllSlidesVisible();
          }
        }
      };

      requestAnimationFrame(animateScroll);
    };

    const handleWheel = (e) => {
      if (isScrollingRef.current) return;

      e.preventDefault();
      e.stopPropagation();

      wheelDelta += e.deltaY;

      clearTimeout(wheelTimer);
      wheelTimer = setTimeout(() => {
        if (Math.abs(wheelDelta) > 100) { // Increased threshold for better control
          if (wheelDelta > 0 && currentStep < ecosystemData.length - 1) {
            // Scroll right (next slide)
            currentStep++;
            smoothScrollToSlide(currentStep);
          } else if (wheelDelta < 0 && currentStep > 0) {
            // Scroll left (previous slide)
            currentStep--;
            smoothScrollToSlide(currentStep);
          } else if (wheelDelta < 0 && currentStep === 0) {
            // At first slide, trigger previous section
            if (onPrevSection) {
              setTimeout(() => {
                onPrevSection();
              }, 100);
            }
          } else if (wheelDelta > 0 && currentStep === ecosystemData.length - 1) {
            // At last slide, trigger next section
            if (onAllSlidesVisible) {
              onAllSlidesVisible();
            }
            // Trigger main scroll to next section
            if (onNextSection) {
              setTimeout(() => {
                onNextSection();
              }, 100);
            }
          }
        }
        wheelDelta = 0;
      }, 100); // Increased timeout for better control
    };

    // Add event listener with capture to ensure it gets the event first
    container.addEventListener('wheel', handleWheel, { passive: false, capture: true });

    // Initialize with first slide
    smoothScrollToSlide(0, true);

    return () => {
      container.removeEventListener('wheel', handleWheel, { capture: true });
      clearTimeout(wheelTimer);
    };
  }, [isScrollEnabled, onAllSlidesVisible, onNextSection, onPrevSection, isInitialized, ecosystemData.length]);

  return (
    <div className={styles.gameEcosystemCarousel}>
      <div
        ref={containerRef}
        className={styles.carouselContainer}
      >
        <div className={styles.carouselWrapper}>
          {ecosystemData.map((item, index) => (
            <div
              key={item.id}
              className={styles.carouselSlide}
              style={{
                background: '#000000',
                transition: skipTransitions ? 'none' : 'opacity 0.8s cubic-bezier(0.4, 0, 0.2, 1)'
              }}
            >
              <div className={styles.slideContent}>
                <div className={styles.slideText}>
                  <h1 className={styles.slideTitle} style={{ color: item.color }}>
                    <span style={{
                      fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                      fontSize: '26px',
                      color: '#00e87b',
                      fontWeight: 'normal',
                      textTransform: 'uppercase',
                      letterSpacing: '1px'
                    }}>
                      {item.title}
                    </span>
                  </h1>
                  <p className={styles.slideDescription}>{item.description}</p>
                </div>
                
                {/* Launching and Liberation text container */}
                <div className={styles.slideTextContainer}>
                  {/* Launching text */}
                  <div className={styles.slideLaunchText}>
                    <div className={styles.textTableRow}>
                      <div className={styles.textPrefixCell}>
                        <span className={styles.launchTextPrefix}>Launching: </span>
                      </div>
                      <div className={styles.textValueCell}>
                        <span className={styles.launchTextDate}>{item.launchDate}</span>
                      </div>
                    </div>
                  </div>
                  
                  {/* Liberation text */}
                  <div className={styles.slideGreenText}>
                    <div className={styles.textTableRow}>
                      <div className={styles.textPrefixCell}>
                        <span className={styles.liberationMovePrefix}>Liberation Move: </span>
                      </div>
                      <div className={styles.textValueCell}>
                        <span className={styles.liberationMoveText}>{item.liberationMove}</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              {/* Slide indicator */}
              <div className={styles.slideIndicator}>
                <span className={styles.slideNumber}>{String(index + 1).padStart(2, '0')}</span>
                <span className={styles.slideTotal}>/ {String(ecosystemData.length).padStart(2, '0')}</span>
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Grey text and navigation dots container */}
      <div className={styles.carouselBottomSection}>
        <div className={styles.slideTopText}>
          <span className={styles.topTextLabel}>Four games. Four mirrors of becoming. Each one a portal ‚Äîfrom awareness to ascension.</span>
        </div>
        
      <div className={styles.carouselDots}>
        {ecosystemData.map((_, index) => (
          <div
            key={index}
            className={`${styles.carouselDot} ${currentSlide === index ? styles.carouselDotActive : ''}`}
          />
        ))}
        </div>
      </div>
    </div>
  );
};

// Slide17 - Simple 4-column image grid
const Slide17OverlappingCarousel = () => {
  const teamMembers = [
    {
      id: 1,
      name: "Rod",
      surname: "Chang",
      designation: "The World Builder",
      description: "\"Rod merges motion, myth, and machinery ‚Äî the perfect engineer for narrative worlds. He expands LIFEiDESIGN‚Äôs cinematic universe through sound, story, and speed. Building the visual grammar of the metaverse.\""
    },
    {
      id: 2,
      name: "Vanessa ",
      surname: "Aldrich",
      designation: "The Creative Conscience",
      description: "\"Vanessa moves between arias and archetypes ‚Äî where sound becomes structure and wisdom becomes style.She keeps heart harmonic. The voice that turns vision sacred.\""
    },
    {
      id: 3,
      name: "Yukai",
      surname: "Chow",
      designation: "The Gamification Oracle",
      description: "\"Yu-kai transforms human behavior into blueprints of engagement.He brings the code to LIFEiDESlGN ‚Äî refining every reward, rhythm, and ritual.Engineering motivation into mastery.\""
    },
    {
      id: 4,
      name: "Chris",
      surname: "Do",
      designation: "The Brand Architect",
      description: "\"Chris builds clarity from chaos ‚Äî he turns creative vision into scalable systems.He‚Äôs the one helping LIFEiDESIGN speak the language of value and velocity. Designing the way the world perceives the game.\""
    }
  ];

  return (
    <div className={styles.slide17Container}>
      <div className={styles.slide17HeroSection}>
        <p className={styles.slide17HeroText}>
          Game is a gang sport. Meet the visionaries who turn individual potential into collective power.
        </p>
      </div>
      
      <div className={styles.slide17ImageGrid}>
        {teamMembers.map((member, index) => (
          <div key={member.id} className={styles.slide17ImageWrapper}>
            <Image
              src={`/image${(index % 4) + 1}.jpg`}
              width={200}
              height={200}
              alt={`${member.name} ${member.surname}`}
              className={styles.slide17Image}
            />
            {/* Name positioned at bottom left of card */}
            <div className={styles.slide17CardName}>
                <h3 className={styles.slide17MemberName}>
                {member.name}
                </h3>
              <h3 className={styles.slide17MemberSurname}>
                {member.surname}
              </h3>
            </div>
            {/* Overlay that appears on hover */}
            <div className={styles.slide17ImageOverlay}>
              <div className={styles.slide17OverlayContent}>
                <div className={styles.slide17OverlayCenter}>
                  <p className={styles.slide17MemberDescription}>
                    {member.description}
                  </p>
                </div>
                <div className={styles.slide17OverlayBottom}>
                <p className={styles.slide17MemberDesignation}>
                  {member.designation}
                </p>
                </div>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};

// Slide18OverlappingCarousel component for gameGang2 slide with 9 overlapping cards
const Slide18OverlappingCarousel = ({ onAllCardsVisible, onNextSection, onPrevSection, currentSection, isScrollEnabled = true }) => {
  console.log('Slide18OverlappingCarousel rendered with:', { currentSection, isScrollEnabled });

  const containerRef = useRef(null);
  const cardsStackRef = useRef(null);
  const [activeCard, setActiveCard] = useState(0);
  const [isInitialized, setIsInitialized] = useState(false);
  const isScrollingRef = useRef(false);

  const slide18CardsData = [
    {
      id: 0,
      title: "Ava Li",
      description: "\"Mirror Mode destroyed every illusion I had about 'user experience.' Turns out, the real UX is life itself ‚Äî and LIFEiDESIGN is the interface.\"",
      designation: "Product Designer, Singapore",
      color: "#ff6b6b"
    },
    {
      id: 1,
      title: "Rafael Costa",
      description: "\"I thought I knew storytelling until Hero Mode. LIFEiDESIGN doesn't help you 'find your voice' ‚Äî it makes your voice find you.\"",
      designation: "Brand Director, S√£o Paulo",
      color: "#4ecdc4"
    },
    {
      id: 2,
      title: "Leena Patel",
      description: "\"NPC Mode flipped my idea of wealth on its head. I realized I didn't want more money ‚Äî I wanted more meaning. I'd invest in this before any startup.\"",
      designation: "Entrepreneur & Angel Investor, London",
      color: "#45b7d1"
    },
    {
      id: 3,
      title: "Noah Rivers",
      description: "\"Monk Mode was my ego's dojo. I've done ayahuasca, silent retreats, and endless meditation ‚Äî none of them showed me my patterns this precisely. This is gamified shadow work.\"",
      designation: "Spiritual Coach, Sedona",
      color: "#f7b731"
    },
    {
      id: 4,
      title: "Dmitri Volkov",
      description: "\"The architecture is wild ‚Äî like if Notion, Jung, and The Matrix had a child. Every decision changes your interface with reality. I didn't just play the game ‚Äî the game played me back.\"",
      designation: "Product Manager, Berlin",
      color: "#5f27cd"
    },
    {
      id: 5,
      title: "Nia Calder√≥n",
      description: "\"StoryiDesign taught me that fiction is the future. It's not about escaping reality ‚Äî it's about designing it. I met my new self in Human Mode‚Ä¶ and she's brilliant.\"",
      designation: "Actor & Writer, Los Angeles",
      color: "#00d2d3"
    },
    {
      id: 6,
      title: "Arjun Mehta",
      description: "\"LIFEiDESIGN is the MBA of consciousness. Strategy, story, psychology ‚Äî all merged into a living system. It made my five-year plan feel one-dimensional.\"",
      designation: "Business Leader, Mumbai",
      color: "#ff9ff3"
    },
    {
      id: 7,
      title: "Dr. Helena Strauss",
      description: "\"For the first time, philosophy feels playable. God Mode is not a metaphor ‚Äî it's a mirror. I no longer 'think about' purpose. I live it.\"",
      designation: "Philosopher & Scholar, Vienna",
      color: "#54a0ff"
    },
    {
      id: 8,
      title: "Elon Kai",
      description: "\"This isn't self-help ‚Äî it's self-simulation. LIFEiDESIGN gives civilization what religion tried to: a framework for becoming. You have to play it to believe it ‚Äî and once you do, there's no going back.\"",
      designation: "Futurist & Policy Advisor, Tokyo",
      color: "#5f27cd"
    }
  ];

  // Animate cards to show 3 columns with stacking effect - each column reveals cards independently
  const animateToStep = useCallback((step) => {
    setActiveCard(step);

    // Get all card wrappers for each column
    const column1Cards = cardsStackRef.current?.querySelectorAll(`.${styles.slide18Column1} .${styles.slide18CardWrapper}`);
    const column2Cards = cardsStackRef.current?.querySelectorAll(`.${styles.slide18Column2} .${styles.slide18CardWrapper}`);
    const column3Cards = cardsStackRef.current?.querySelectorAll(`.${styles.slide18Column3} .${styles.slide18CardWrapper}`);

    if (!column1Cards || !column2Cards || !column3Cards) return;

    // All columns should show cards up to the current step
    [column1Cards, column2Cards, column3Cards].forEach((columnCards, columnIndex) => {
      columnCards.forEach((wrapper, cardIndex) => {
        const card = wrapper.querySelector(`.${styles.slide18OverlappingCard}`);
        if (!card) return;

        if (cardIndex <= step) {
          // Cards that should be visible and stacked (stack upwards like Slide 17)
          const stackOffset = cardIndex * 60; // Increased overlap distance
          const baseOffset = -100; // Move all cards up to prevent bottom cutoff
          wrapper.style.transform = `translateY(${baseOffset + stackOffset}px)`;
          card.style.opacity = '1';
          card.style.zIndex = (3 - cardIndex); // Higher z-index for cards that appear later

          // The topmost visible card in each column gets active styling
          if (cardIndex === step) {
            card.style.transform = 'scale(1.02)';
            card.classList.add(styles.slide18CardActive);
          } else {
            card.style.transform = 'scale(1)';
            card.classList.remove(styles.slide18CardActive);
          }
        } else {
          // Future cards - keep hidden below the stack
          wrapper.style.transform = `translateY(${window.innerHeight}px)`;
          card.style.opacity = '0';
          card.style.zIndex = (3 - cardIndex);
          card.style.transform = 'scale(1)';
          card.classList.remove(styles.slide18CardActive);
        }
      });
    });
  }, []);

  // Initialize component
  useEffect(() => {
    setIsInitialized(true);
    // Small delay to ensure DOM is ready
    const timer = setTimeout(() => {
      animateToStep(0); // Start with first step (no cards visible)
    }, 100);

    return () => clearTimeout(timer);
  }, [animateToStep]);

  // Reset when entering slide 18 (currentSection === 17)
  useEffect(() => {
    if (!isInitialized) return;

    if (currentSection === 17 && isScrollEnabled) {
      animateToStep(0);
    }
  }, [currentSection, isScrollEnabled, isInitialized, animateToStep]);

  // Handle subscroll functionality
  useEffect(() => {
    const container = containerRef.current;
    if (!container || !isInitialized) return;

    console.log('Slide18: Setting up wheel listeners, isScrollEnabled:', isScrollEnabled, 'currentSection:', currentSection);

    // If scroll effect is disabled, don't add wheel listeners
    if (!isScrollEnabled) {
      console.log('Slide18: Scroll disabled, not adding wheel listeners');
      return;
    }

    let wheelDelta = 0;
    let wheelTimer = null;

    const handleWheel = (e) => {
      // Only handle wheel events when we're on slide 18
      if (currentSection !== 17) {
        return;
      }

      console.log('Slide18: Wheel event captured, deltaY:', e.deltaY, 'activeCard:', activeCard);

      if (isScrollingRef.current) {
        console.log('Slide18: Already scrolling, ignoring');
        return;
      }

      e.preventDefault();
      e.stopPropagation();

      wheelDelta += e.deltaY;

      clearTimeout(wheelTimer);
      wheelTimer = setTimeout(() => {
        console.log('Slide18: Processing wheel delta:', wheelDelta, 'activeCard:', activeCard);

        if (Math.abs(wheelDelta) > 50) { // Lower threshold for more responsive
          if (wheelDelta > 0 && activeCard < 2) {
            // Scroll down (next step - reveal next layer of cards in all columns)
            console.log('Slide18: Going to next step:', activeCard + 1);
            animateToStep(activeCard + 1);
          } else if (wheelDelta < 0 && activeCard > 0) {
            // Scroll up (previous step - hide top layer of cards in all columns)
            console.log('Slide18: Going to previous step:', activeCard - 1);
            animateToStep(activeCard - 1);
          } else if (wheelDelta < 0 && activeCard === 0) {
            // At first step, trigger previous section
            console.log('Slide18: At first step, going to previous slide');
            setTimeout(() => {
              if (window.gotoPrevSlide) {
                window.gotoPrevSlide();
              }
            }, 100);
          } else if (wheelDelta > 0 && activeCard === 2) {
            // At last step (all 3 cards in each column visible), trigger next section
            console.log('Slide18: At last step, going to next slide');
            if (onAllCardsVisible) {
              onAllCardsVisible();
            }
            // Trigger main scroll to next section
            setTimeout(() => {
              if (window.gotoNextSlide) {
                window.gotoNextSlide();
              }
            }, 100);
          }
        }
        wheelDelta = 0;
      }, 50); // Shorter timeout for more responsive
    };

    // Add event listener to document to capture all wheel events
    document.addEventListener('wheel', handleWheel, { passive: false, capture: true });

    return () => {
      document.removeEventListener('wheel', handleWheel, { capture: true });
      clearTimeout(wheelTimer);
    };
  }, [isScrollEnabled, onAllCardsVisible, onNextSection, onPrevSection, isInitialized, activeCard, animateToStep, currentSection]);

  return (
    <div className={styles.slide18OverlappingCardsContainer} ref={containerRef}>
      <div className={styles.slide18CardsStack} ref={cardsStackRef}>
        {/* Column 1 */}
        <div className={`${styles.slide18Column} ${styles.slide18Column1}`}>
          {slide18CardsData.slice(0, 3).map((card, index) => (
            <div
              key={card.id}
              className={styles.slide18CardWrapper}
              style={{
                zIndex: index + 1
              }}
            >
              <div
                className={`${styles.slide18OverlappingCard}`}
                style={{
                  '--card-color': card.color,
                  background: '#000000'
                }}
              >
                <div className={styles.slide12CardContent}>
                  <h3 className={styles.slide12CardTitle}>
                    <span style={{
                      fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                      fontSize: '26px',
                      color: '#00e87b',
                      fontWeight: 'normal',
                      textTransform: 'uppercase',
                      letterSpacing: '1px'
                    }}>
                      {card.title}
                    </span>
                  </h3>
                  <div className={styles.slide12CardTitleDivider}></div>
                  <p className={styles.slide12CardDescription}>{card.description}</p>
                  <p className={styles.slide12CardDesignation} style={{
                    fontSize: '14px',
                    color: '#888',
                    fontStyle: 'italic',
                    marginTop: '8px'
                  }}>{card.designation}</p>
                  <div className={styles.slide12CardNumber}>{String(index + 1).padStart(2, '0')}</div>
                </div>
              </div>
            </div>
          ))}
        </div>

        {/* Column 2 */}
        <div className={`${styles.slide18Column} ${styles.slide18Column2}`}>
          {slide18CardsData.slice(3, 6).map((card, index) => (
            <div
              key={card.id}
              className={styles.slide18CardWrapper}
              style={{
                zIndex: index + 1
              }}
            >
              <div
                className={`${styles.slide18OverlappingCard}`}
                style={{
                  '--card-color': card.color,
                  background: '#000000'
                }}
              >
                <div className={styles.slide12CardContent}>
                  <h3 className={styles.slide12CardTitle}>
                    <span style={{
                      fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                      fontSize: '26px',
                      color: '#00e87b',
                      fontWeight: 'normal',
                      textTransform: 'uppercase',
                      letterSpacing: '1px'
                    }}>
                      {card.title}
                    </span>
                  </h3>
                  <div className={styles.slide12CardTitleDivider}></div>
                  <p className={styles.slide12CardDescription}>{card.description}</p>
                  <p className={styles.slide12CardDesignation} style={{
                    fontSize: '14px',
                    color: '#888',
                    fontStyle: 'italic',
                    marginTop: '8px'
                  }}>{card.designation}</p>
                  <div className={styles.slide12CardNumber}>{String(index + 4).padStart(2, '0')}</div>
                </div>
              </div>
            </div>
          ))}
        </div>

        {/* Column 3 */}
        <div className={`${styles.slide18Column} ${styles.slide18Column3}`}>
          {slide18CardsData.slice(6, 9).map((card, index) => (
            <div
              key={card.id}
              className={styles.slide18CardWrapper}
              style={{
                zIndex: index + 1
              }}
            >
              <div
                className={`${styles.slide18OverlappingCard}`}
                style={{
                  '--card-color': card.color,
                  background: '#000000'
                }}
              >
                <div className={styles.slide12CardContent}>
                  <h3 className={styles.slide12CardTitle}>
                    <span style={{
                      fontFamily: '"Full Moon BT W01 Falling Leav", "satoshi", sans-serif',
                      fontSize: '26px',
                      color: '#00e87b',
                      fontWeight: 'normal',
                      textTransform: 'uppercase',
                      letterSpacing: '1px'
                    }}>
                      {card.title}
                    </span>
                  </h3>
                  <div className={styles.slide12CardTitleDivider}></div>
                  <p className={styles.slide12CardDescription}>{card.description}</p>
                  <p className={styles.slide12CardDesignation} style={{
                    fontSize: '14px',
                    color: '#888',
                    fontStyle: 'italic',
                    marginTop: '8px'
                  }}>{card.designation}</p>
                  <div className={styles.slide12CardNumber}>{String(index + 7).padStart(2, '0')}</div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Progress indicator */}
      <div className={styles.slide18ProgressIndicator}>
        <div className={styles.slide18ProgressBar}>
          <div
            className={styles.slide18ProgressFill}
            style={{
              width: `${(activeCard / 2) * 100}%`
            }}
          />
        </div>
        <span className={styles.slide18ProgressText}>
          Step {activeCard + 1} / 3
        </span>
      </div>
    </div>
  );
};

const PallaxPage = () => {
  const sectionsRef = useRef([]);
  const imagesRef = useRef([]);
  const headingsRef = useRef([]);
  const outerWrappersRef = useRef([]);
  const innerWrappersRef = useRef([]);
  const splitHeadingsRef = useRef([]);
  const currentIndexRef = useRef(-1);
  const animatingRef = useRef(false);
  const wheelTimeoutRef = useRef(null);
  const isScrollPausedRef = useRef(false);
  const scrollContainerRef = useRef(null);
  const subscrollTransitionRef = useRef(false);
  const lastSubscrollSectionRef = useRef(-1);
  const [selectedMember, setSelectedMember] = useState(0);
  const [currentSection, setCurrentSection] = useState(0);
  const [isMuted, setIsMuted] = useState(false);
  const [isHoveringProgress, setIsHoveringProgress] = useState(false);
  const [isHoveringCube, setIsHoveringCube] = useState(false);
  const [selectedMode, setSelectedMode] = useState(0);
  const [expandedFAQ, setExpandedFAQ] = useState(null);
  const [currentVideoIndex, setCurrentVideoIndex] = useState(0);
  const [videoStates, setVideoStates] = useState({});
  const videoRefs = useRef([]);
  const progressTimeoutRef = useRef(null);
  const gotoSectionRef = useRef(null);

  // Video control functions
  const togglePlayPause = (index) => {
    const video = videoRefs.current[index];
    if (!video) return;

    if (video.paused) {
      video.play();
      setVideoStates(prev => ({
        ...prev,
        [index]: { ...prev[index], isPlaying: true }
      }));
    } else {
      video.pause();
      setVideoStates(prev => ({
        ...prev,
        [index]: { ...prev[index], isPlaying: false }
      }));
    }
  };

  const updateProgress = (index) => {
    const video = videoRefs.current[index];
    if (!video) return;

    const progress = (video.currentTime / video.duration) * 100;
    setVideoStates(prev => ({
      ...prev,
      [index]: {
        ...prev[index],
        progress,
        currentTime: video.currentTime
      }
    }));
  };

  const updateDuration = (index) => {
    const video = videoRefs.current[index];
    if (!video) return;

    setVideoStates(prev => ({
      ...prev,
      [index]: {
        ...prev[index],
        duration: video.duration
      }
    }));
  };

  const seekVideo = (index, e) => {
    const video = videoRefs.current[index];
    if (!video) return;

    const rect = e.currentTarget.getBoundingClientRect();
    const clickX = e.clientX - rect.left;
    const percentage = clickX / rect.width;
    video.currentTime = percentage * video.duration;
  };

  const formatTime = (seconds) => {
    if (!seconds || isNaN(seconds)) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const sections = [
    {
      type: "reviews",
      className: "first"
    },
    {
      type: "hero",
      className: "second"
    },
    {
      type: "demo",
      className: "third"
    },
    {
      type: "features",
      className: "fourth"
    },
    {
      type: "cta",
      className: "fifth"
    },
    {
      type: "heroFlipped",
      className: "sixth"
    },
    {
      type: "cta2",
      className: "seventh"
    },
    {
      type: "powers",
      className: "eighth"
    },
    {
      type: "gains",
      className: "ninth"
    },
    {
      type: "gameFlow",
      className: "tenth"
    },
    {
      type: "heroFinal",
      className: "eleventh"
    },
    {
      type: "designModes",
      className: "twelfth"
    },
    {
      type: "designModesFlipped",
      className: "thirteenth"
    },
    {
      type: "gameEcosystem",
      className: "fourteenth"
    },
    {
      type: "gameModes",
      className: "fifteenth"
    },
    {
      type: "ddIntroduction",
      className: "sixteenth"
    },
    {
      type: "gameGang",
      className: "seventeenth"
    },
    {
      type: "gameGang2",
      className: "eighteenth"
    },
    {
      type: "faq",
      className: "nineteenth"
    },
    {
      type: "gamePass",
      className: "twentieth"
    },
    {
      type: "contact",
      className: "twentyfirst"
    }
  ];

  // Hide navbar on this page
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const navbar = document.querySelector('nav');
    if (navbar) {
      navbar.style.display = 'none';
    }

    // Show navbar when component unmounts
    return () => {
      if (navbar) {
        navbar.style.display = '';
      }
    };
  }, []);

  // Cleanup progress timeout on unmount
  useEffect(() => {
    return () => {
      if (progressTimeoutRef.current) {
        clearTimeout(progressTimeoutRef.current);
      }
    };
  }, []);

  // Toggle mute function
  const toggleMute = () => {
    setIsMuted(!isMuted);
  };

  const toggleFAQ = useCallback((index) => {
    setExpandedFAQ(expandedFAQ === index ? null : index);
  }, [expandedFAQ]);

  // Scroll to specific section function
  const scrollToSection = useCallback((sectionIndex) => {
    if (typeof window === 'undefined') return;

    const currentIndex = currentIndexRef.current;
    const direction = sectionIndex > currentIndex ? 1 : -1;

    console.log('scrollToSection called:', { sectionIndex, currentIndex, direction });
    console.log('gotoSectionRef.current:', gotoSectionRef.current);

    // Update current section
    setCurrentSection(sectionIndex);

    // Use the gotoSection function from the ref
    if (gotoSectionRef.current) {
      console.log('Calling gotoSection with:', sectionIndex, direction);
      gotoSectionRef.current(sectionIndex, direction);
    } else {
      console.error('gotoSection function not available');
    }
  }, []);

  // Floating Arrow Component for navigation (bottom center)
  const FloatingArrow = ({ currentSection, onNextSlide, isVisible }) => {
    const handleClick = () => {
      // Go to next section, but don't cycle back to first
      const nextSection = currentSection + 1;
      if (nextSection < sections.length) {
        onNextSlide(nextSection);
      }
    };

    return (
      <div
        className={styles.floatingArrow}
        onClick={handleClick}
        style={{
          opacity: isVisible ? 1 : 0,
          pointerEvents: isVisible ? 'auto' : 'none'
        }}
      >
        <svg
          width="40"
          height="40"
          viewBox="0 0 24 24"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
          className={styles.arrowSvg}
        >
          <path
            d="M7 13L12 18L17 13"
            stroke="#00e87b"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          />
          <path
            d="M12 18V6"
            stroke="#00e87b"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          />
        </svg>
      </div>
    );
  };

  // VibeCheckButton Component for bottom right
  const VibeCheckButton = ({ currentSection, onNextSlide }) => {
    const [isExpanded, setIsExpanded] = useState(false);

    const handleClick = () => {
      // Navigate to the website
      window.open('https://app.lifeidesign.games', '_blank');
    };

    const shouldShow = currentSection >= 1;

    useEffect(() => {
      if (shouldShow) {
        // Button appears first, then expands after delay
        const expandTimer = setTimeout(() => {
          setIsExpanded(true);
        }, 1200);
        return () => clearTimeout(expandTimer);
      } else {
        setIsExpanded(false);
      }
    }, [shouldShow]);

    if (!shouldShow) {
      return null;
    }

    return (
      <div
        className={`${styles.floatingButton} ${styles.floatingButtonVisible} ${isExpanded ? styles.expanded : ''}`}
        onClick={handleClick}
        aria-label={isExpanded ? "Check Game Vibe" : "Open Check Game Vibe"}
      >
        {/* Arrow icon at the start */}
        <svg
          viewBox="0 0 960 600"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
          className={styles.buttonArrowSvg}
          aria-hidden="true"
        >
          <path d="M0 240V360H720V480H840V360H960V240H840V120H720V240H0Z" fill="currentColor" />
          <path d="M720 0H600V120H720V0Z" fill="currentColor" />
          <path d="M720 480H600V600H720V480Z" fill="currentColor" />
        </svg>

        {/* Spacer between arrow and text */}
        <span
          aria-hidden="true"
          className={styles.buttonSpacer}
        />

        {/* Text that slides up from below */}
        <span className={styles.textWrapper}>
          <span className={`${styles.buttonText} ${isExpanded ? styles.textVisible : styles.textHidden}`}>
            Check Game Vibe
          </span>
        </span>
      </div>
    );
  };

  useEffect(() => {
    if (typeof window === 'undefined') return;

    const sections = sectionsRef.current;
    const images = imagesRef.current;
    const headings = headingsRef.current;
    const outerWrappers = outerWrappersRef.current;
    const innerWrappers = innerWrappersRef.current;
    const splitHeadings = splitHeadingsRef.current;
    let currentIndex = currentIndexRef.current;
    let animating = animatingRef.current;
    const wrap = gsap.utils.wrap(0, sections.length);

    // Initialize SplitText
    const initializeSplitText = () => {
      headings.forEach((heading, index) => {
        if (heading && typeof SplitText !== 'undefined') {
          try {
            splitHeadings[index] = new SplitText(heading, {
              type: "chars,words,lines",
              linesClass: "clip-text"
            });
          } catch (error) {
            console.warn('SplitText failed, using fallback:', error);
            // Fallback: create simple character splits manually
            const text = heading.textContent;
            heading.innerHTML = text.split('').map(char =>
              `<span class="char">${char}</span>`
            ).join('');
            splitHeadings[index] = { chars: heading.querySelectorAll('.char') };
          }
        }
      });
    };

    // Initialize the animation
    const initAnimation = () => {
      // Set all sections hidden initially
      gsap.set(sections, { autoAlpha: 0 });

      // Initialize all wrappers and images to default positions
      gsap.set(outerWrappers, { yPercent: 100, xPercent: 0 });
      gsap.set(innerWrappers, { yPercent: -100, xPercent: 0 });
      gsap.set(images, { yPercent: 0, xPercent: 0 });

      // Set first section visible and in position
      gsap.set(sections[0], { autoAlpha: 1, zIndex: 1 });
      gsap.set([outerWrappers[0], innerWrappers[0]], { yPercent: 0, xPercent: 0 });
      gsap.set(images[0], { yPercent: 0, xPercent: 0 });

      // Initialize first section text if it exists
      if (splitHeadings[0] && splitHeadings[0].chars) {
        gsap.set(splitHeadings[0].chars, { autoAlpha: 1, yPercent: 0, xPercent: 0 });
      }

      // Set current index to 0
      currentIndex = 0;
      currentIndexRef.current = 0;

      const gotoSection = (index, direction) => {
        console.log('gotoSection called with:', { index, direction, currentIndex });
        // Prevent cyclic navigation - only allow valid indices
        if (index < 0 || index >= sections.length) {
          console.log('Invalid index, preventing navigation:', index);
          return;
        }
        animating = true;
        animatingRef.current = true;

        // Reset wheel delta and clear timer when transitioning between sections
        wheelDelta = 0;
        if (wheelTimer) {
          clearTimeout(wheelTimer);
          wheelTimer = null;
        }

        const fromTop = direction === -1;
        const dFactor = fromTop ? -1 : 1;


        const tl = gsap.timeline({
          defaults: { duration: 0.8, ease: "power2.inOut" },
          onComplete: () => {
            animating = false;
            animatingRef.current = false;
          }
        });

        if (currentIndex >= 0) {
          // The first time this function runs, current is -1
          gsap.set(sections[currentIndex], { zIndex: 0 });

          // Vertical transition: slide up/down
          tl.to(images[currentIndex], { yPercent: -15 * dFactor })
            .set(sections[currentIndex], { autoAlpha: 0 });
        }

        gsap.set(sections[index], { autoAlpha: 1, zIndex: 1 });

        // Vertical transition: slide up/down

        // Reset any horizontal positioning first
        gsap.set([outerWrappers[index], innerWrappers[index]], { xPercent: 0 });
        gsap.set(images[index], { xPercent: 0 });

        tl.fromTo([outerWrappers[index], innerWrappers[index]], {
          yPercent: i => i ? -100 * dFactor : 100 * dFactor
        }, {
          yPercent: 0
        }, 0)
          .fromTo(images[index], { yPercent: 15 * dFactor }, { yPercent: 0 }, 0);

        // Add text animation if splitHeadings exists
        if (splitHeadings[index] && splitHeadings[index].chars) {
          // Vertical text animation

          // Reset horizontal positioning for text
          gsap.set(splitHeadings[index].chars, { xPercent: 0 });

          tl.fromTo(splitHeadings[index].chars, {
            autoAlpha: 0,
            yPercent: 150 * dFactor
          }, {
            autoAlpha: 1,
            yPercent: 0,
            duration: 0.6,
            ease: "power2.out",
            stagger: {
              each: 0.015,
              from: "random"
            }
          }, 0.1);
        }

        currentIndex = index;
        currentIndexRef.current = index;

        // Check if this is slide 3 (demo), slide 4 (features), slide 5 (cta), slide 7 (cta2), slide 8 (powers), slide 9 (gains), slide 10 (gameFlow), slide 12 (designModes), slide 13 (designModesFlipped), slide 14 (gameEcosystem), slide 15 (gameModes), or slide 18 (gameGang2) and coming from forward direction - pause GSAP scrolling
        const subscrollSections = [2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14, 17];
        const isEnteringSubscroll = subscrollSections.includes(index) && direction === 1;
        const wasInSubscroll = subscrollSections.includes(lastSubscrollSectionRef.current);

        if (isEnteringSubscroll) {
          isScrollPausedRef.current = true;

          // Special handling for consecutive subscroll sections (like slide 4->5)
          const isConsecutiveSubscroll = wasInSubscroll &&
            subscrollSections.includes(index) &&
            Math.abs(index - lastSubscrollSectionRef.current) === 1;

          if (isConsecutiveSubscroll) {
            subscrollTransitionRef.current = true;
            // Longer delay for consecutive subscroll transitions
            setTimeout(() => {
              subscrollTransitionRef.current = false;
            }, 2000);
          }

          lastSubscrollSectionRef.current = index;
        } else {
          // Ensure scrolling is fully enabled for non-subscroll sections
          isScrollPausedRef.current = false;
          subscrollTransitionRef.current = false;
          if (!subscrollSections.includes(index)) {
            lastSubscrollSectionRef.current = -1;
          }
        }

        setCurrentSection(index);
      };

      // Store the gotoSection function in the ref so it can be accessed by scrollToSection
      gotoSectionRef.current = gotoSection;

      // Expose gotoSection globally for ScrollRevealSection
      window.gotoNextSlide = () => {
        if (!animating && !animatingRef.current && !subscrollTransitionRef.current && (currentIndex === 2 || currentIndex === 3 || currentIndex === 4 || currentIndex === 6 || currentIndex === 7 || currentIndex === 8 || currentIndex === 9 || currentIndex === 11 || currentIndex === 12 || currentIndex === 13 || currentIndex === 14)) {
          // Only go to next slide if not at the last slide
          if (currentIndex < sections.length - 1) {
            gotoSection(currentIndex + 1, 1);
          }
        }
      };

      window.gotoPrevSlide = () => {
        if (!animating && !animatingRef.current && !subscrollTransitionRef.current && (currentIndex === 2 || currentIndex === 3 || currentIndex === 4 || currentIndex === 6 || currentIndex === 7 || currentIndex === 8 || currentIndex === 9 || currentIndex === 11 || currentIndex === 12 || currentIndex === 13 || currentIndex === 14)) {
          // Only go to previous slide if not at the first slide
          if (currentIndex > 0) {
            gotoSection(currentIndex - 1, -1);
          }
        }
      };

      // Expose subscroll transition state globally
      window.isSubscrollTransitioning = () => subscrollTransitionRef.current;

      // Use native wheel event with delta accumulation
      let wheelDelta = 0;
      let wheelTimer = null;

      const handleWheel = (e) => {
        // If we're on a subscroll section and scrolling is paused, allow native scrolling
        if (isScrollPausedRef.current) {
          return; // Let browser handle native scroll
        }

        e.preventDefault();

        if (animating || animatingRef.current || subscrollTransitionRef.current) return;

        // Accumulate wheel delta
        wheelDelta += e.deltaY;

        // Clear existing timer
        if (wheelTimer) {
          clearTimeout(wheelTimer);
        }

        // Wait for wheel events to settle
        wheelTimer = setTimeout(() => {
          if (Math.abs(wheelDelta) > 50) { // Threshold to prevent accidental triggers
            if (wheelDelta > 0) {
              // Scroll down - go to next section
              gotoSection(currentIndex + 1, 1);
            } else {
              // Scroll up - go to previous section
              gotoSection(currentIndex - 1, -1);
            }
          }
          wheelDelta = 0; // Reset delta
        }, 10); // Very short delay to accumulate wheel events
      };

      document.addEventListener('wheel', handleWheel, { passive: false });

      // Cleanup function
      return () => {
        document.removeEventListener('wheel', handleWheel);
        if (wheelTimer) clearTimeout(wheelTimer);
        clearTimeout(wheelTimeoutRef.current);
        // Clean up global functions
        if (window.gotoNextSlide) {
          delete window.gotoNextSlide;
        }
        if (window.gotoPrevSlide) {
          delete window.gotoPrevSlide;
        }
        if (window.isSubscrollTransitioning) {
          delete window.isSubscrollTransitioning;
        }
      };
    };

    // Initialize SplitText first, then animation
    initializeSplitText();
    const cleanup = initAnimation();

    return cleanup;
  }, []);

  const renderSectionContent = (section, index) => {
    switch (section.type) {
      case "hero":
        return <Slide2Hero />;

      case "reviews":
        return <Slide1Reviews onNextSlide={() => scrollToSection(currentSection + 1)} />;

      case "demo":
        return (
          <ScrollRevealSectionSlide3
            currentSection={currentSection}
            isScrollEnabled={isScrollPausedRef.current}
            isTransitioning={subscrollTransitionRef.current}
            onAllColumnsVisible={() => {
              // Resume GSAP scrolling when all content is visible
              setTimeout(() => {
                isScrollPausedRef.current = false;
              }, 500); // Small delay to ensure smooth transition
            }}
            currentVideoIndex={currentVideoIndex}
            setCurrentVideoIndex={setCurrentVideoIndex}
            videoStates={videoStates}
            setVideoStates={setVideoStates}
            videoRefs={videoRefs}
            togglePlayPause={togglePlayPause}
            updateProgress={updateProgress}
            updateDuration={updateDuration}
            seekVideo={seekVideo}
          />
        );

      case "features":
        return (
          <ScrollRevealSectionSlide4
            currentSection={currentSection}
            isScrollEnabled={isScrollPausedRef.current}
            isTransitioning={subscrollTransitionRef.current}
            onAllColumnsVisible={() => {
              // Resume GSAP scrolling when all columns are visible
              setTimeout(() => {
                isScrollPausedRef.current = false;
              }, 500); // Small delay to ensure smooth transition
            }}
          />
        );

      case "cta":
        return (
          <ScrollRevealSectionSlide5
            currentSection={currentSection}
            isScrollEnabled={isScrollPausedRef.current}
            isTransitioning={subscrollTransitionRef.current}
            onAllColumnsVisible={() => {
              // Resume GSAP scrolling when all columns are visible
              setTimeout(() => {
                isScrollPausedRef.current = false;
              }, 500); // Small delay to ensure smooth transition
            }}
          />
        );

      case "heroFlipped":
        return <Slide6HeroFlipped />;

      case "cta2":
        return (
          <ScrollRevealSection
            currentSection={currentSection}
            isScrollEnabled={isScrollPausedRef.current}
            onAllColumnsVisible={() => {
              // Resume GSAP scrolling when all columns are visible
              setTimeout(() => {
                isScrollPausedRef.current = false;
              }, 500); // Small delay to ensure smooth transition
            }}
          />
        );

      case "powers":
        return (
          <ScrollRevealSectionSlide8
            currentSection={currentSection}
            isScrollEnabled={isScrollPausedRef.current}
            onAllColumnsVisible={() => {
              // Resume GSAP scrolling when all columns are visible
              setTimeout(() => {
                isScrollPausedRef.current = false;
              }, 500); // Small delay to ensure smooth transition
            }}
          />
        );

      case "gains":
        return (
          <ScrollRevealSectionSlide9
            currentSection={currentSection}
            isScrollEnabled={isScrollPausedRef.current}
            onAllColumnsVisible={() => {
              // Resume GSAP scrolling when all columns are visible
              setTimeout(() => {
                isScrollPausedRef.current = false;
              }, 500); // Small delay to ensure smooth transition
            }}
          />
        );

      case "gameFlow":
        return (
          <ScrollRevealSectionSlide10
            currentSection={currentSection}
            isScrollEnabled={isScrollPausedRef.current}
            onAllColumnsVisible={() => {
              // Resume GSAP scrolling when all columns are visible
              setTimeout(() => {
                isScrollPausedRef.current = false;
              }, 500); // Small delay to ensure smooth transition
            }}
          />
        );

      case "heroFinal":
        return <Slide11HeroFinal />;

      case "designModes":
        return (
          <div className={styles.slide12Container}>
            <div className={styles.slide12ContentWrapper}>
              {/* Top hero paragraph - always visible */}
              <div className={styles.slide12HeroSection}>
                <p className={styles.slide12HeroText}>
                Every quest unveils a higher view,
each move reveals a deeper you.<br />
 From mirror to myth, the game expands,
 design thyself ‚Äî with your own hands.

                </p>
              </div>

              <div className={styles.pallaxInteractiveLayout}>
                <div className={styles.pallaxTitlesSection}>

                  <div className={`${styles.pallaxTitleButtons} ${styles.pallaxSectionButtons}`}>
                    <button
                      className={`${styles.pallaxTitleButton} ${selectedMode === 0 ? styles.pallaxActive : ''}`}
                      onClick={() => setSelectedMode(0)}
                    >
                      GAMEiDESIGN
                    </button>
                    <button
                      className={`${styles.pallaxTitleButton} ${selectedMode === 1 ? styles.pallaxActive : ''}`}
                      onClick={() => setSelectedMode(1)}
                    >
                      COREiDESIGN
                    </button>
                    <button
                      className={`${styles.pallaxTitleButton} ${selectedMode === 2 ? styles.pallaxActive : ''}`}
                      onClick={() => setSelectedMode(2)}
                    >
                      PLAYiDESIGN
                    </button>
                    <button
                      className={`${styles.pallaxTitleButton} ${selectedMode === 3 ? styles.pallaxActive : ''}`}
                      onClick={() => setSelectedMode(3)}
                    >
                      STORYiDESIGN
                    </button>
                  </div>
                </div>

                <Slide12DesignModesCarousel
                  currentSection={currentSection}
                  isScrollEnabled={isScrollPausedRef.current}
                  onGroupChange={(groupIndex) => {
                    // Update button state based on active card group
                    setSelectedMode(groupIndex);
                  }}
                  onAllCardsVisible={() => {
                    // Resume GSAP scrolling when all cards are viewed
                    setTimeout(() => {
                      isScrollPausedRef.current = false;
                    }, 500);
                  }}
                  onNextSection={() => {
                    // Move to next section
                    const currentIndex = currentIndexRef.current;
                    if (gotoSectionRef.current && currentIndex < sections.length - 1) {
                      gotoSectionRef.current(currentIndex + 1, 1);
                    }
                  }}
                  onPrevSection={() => {
                    // Move to previous section
                    const currentIndex = currentIndexRef.current;
                    if (gotoSectionRef.current && currentIndex > 0) {
                      gotoSectionRef.current(currentIndex - 1, -1);
                    }
                  }}
                />
              </div>
            </div>
          </div>
        );

      case "designModesFlipped":
        return (
          <div className={styles.slide13Container}>
            <div className={styles.slide13ContentWrapper}>
              {/* Top hero paragraph - always visible */}
              <div className={styles.slide13HeroSection}>
                <p className={styles.slide13HeroText}>
                This is the body of LIFEiDESIGN ‚Äî
every tool, ritual, and system designed for one mission:<br />
to make your evolution inevitable.
                </p>
              </div>

              <div className={styles.pallaxInteractiveLayout}>
                <Slide13DesignModesCarousel
                  currentSection={currentSection}
                  isScrollEnabled={isScrollPausedRef.current}
                  onGroupChange={(groupIndex) => {
                    // Update button state based on active card group
                    setSelectedMode(groupIndex);
                  }}
                  onAllCardsVisible={() => {
                    // Resume GSAP scrolling when all cards are viewed
                    const currentIndex = currentIndexRef.current;
                    if (gotoSectionRef.current && currentIndex < sections.length - 1) {
                      gotoSectionRef.current(currentIndex + 1, 1);
                    }
                  }}
                  onNextSection={() => {
                    const currentIndex = currentIndexRef.current;
                    if (gotoSectionRef.current && currentIndex < sections.length - 1) {
                      gotoSectionRef.current(currentIndex + 1, 1);
                    }
                  }}
                  onPrevSection={() => {
                    const currentIndex = currentIndexRef.current;
                    if (gotoSectionRef.current && currentIndex > 0) {
                      gotoSectionRef.current(currentIndex - 1, -1);
                    }
                  }}
                />

                <div className={styles.pallaxTitlesSection}>
                  <div className={`${styles.pallaxTitleButtons} ${styles.pallaxSectionButtons}`}>
                    <button
                      className={`${styles.pallaxTitleButton} ${selectedMode === 0 ? styles.pallaxActive : ''}`}
                      onClick={() => setSelectedMode(0)}
                    >
                      PHYSICAL TOOLKIT
                    </button>
                    <button
                      className={`${styles.pallaxTitleButton} ${selectedMode === 1 ? styles.pallaxActive : ''}`}
                      onClick={() => setSelectedMode(1)}
                    >
                      DIGITAL PRODUCTS
                    </button>
                    <button
                      className={`${styles.pallaxTitleButton} ${selectedMode === 2 ? styles.pallaxActive : ''}`}
                      onClick={() => setSelectedMode(2)}
                    >
                      GAME RESIDENCY
                    </button>
                    <button
                      className={`${styles.pallaxTitleButton} ${selectedMode === 3 ? styles.pallaxActive : ''}`}
                      onClick={() => setSelectedMode(3)}
                    >
                      SUPPORT SYSTEM
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );

      case "gameModes":
        return (
          <Slide15GameModesCarousel
            currentSection={currentSection}
            isScrollEnabled={isScrollPausedRef.current}
            onAllSlidesVisible={() => {
              // Resume GSAP scrolling when all slides are viewed
              setTimeout(() => {
                isScrollPausedRef.current = false;
              }, 500);
            }}
            onNextSection={() => {
              // Move to next section
              const currentIndex = currentIndexRef.current;
              if (gotoSectionRef.current && currentIndex < sections.length - 1) {
                gotoSectionRef.current(currentIndex + 1, 1);
              }
            }}
            onPrevSection={() => {
              // Move to previous section
              const currentIndex = currentIndexRef.current;
              if (gotoSectionRef.current && currentIndex > 0) {
                gotoSectionRef.current(currentIndex - 1, -1);
              }
            }}
          />
        );

      case "gameEcosystem":
        return (
          <GameEcosystemCarousel
            currentSection={currentSection}
            isScrollEnabled={isScrollPausedRef.current}
            onAllSlidesVisible={() => {
              // Resume GSAP scrolling when all slides are viewed
              setTimeout(() => {
                isScrollPausedRef.current = false;
              }, 500);
            }}
            onNextSection={() => {
              // Move to next section
              const currentIndex = currentIndexRef.current;
              if (gotoSectionRef.current && currentIndex < sections.length - 1) {
                gotoSectionRef.current(currentIndex + 1, 1);
              }
            }}
            onPrevSection={() => {
              // Move to previous section
              const currentIndex = currentIndexRef.current;
              if (gotoSectionRef.current && currentIndex > 0) {
                gotoSectionRef.current(currentIndex - 1, -1);
              }
            }}
          />
        );

      case "ddIntroduction":
        return <Slide16DDIntroduction currentSection={currentSection} />;

      case "gameGang":
        return <Slide17OverlappingCarousel />;

      case "gameGang2":
        return (
          <Slide18OverlappingCarousel
            currentSection={currentSection}
            isScrollEnabled={isScrollPausedRef.current}
            onAllCardsVisible={() => {
              // Resume GSAP scrolling when all cards are viewed
              setTimeout(() => {
                isScrollPausedRef.current = false;
              }, 500);
            }}
            onNextSection={() => {
              // Move to next section
              const currentIndex = currentIndexRef.current;
              if (gotoSectionRef.current && currentIndex < sections.length - 1) {
                gotoSectionRef.current(currentIndex + 1, 1);
              }
            }}
            onPrevSection={() => {
              // Move to previous section
              const currentIndex = currentIndexRef.current;
              if (gotoSectionRef.current && currentIndex > 0) {
                gotoSectionRef.current(currentIndex - 1, -1);
              }
            }}
          />
        );

      case "faq":
        return (
          <Slide19FAQ
            expandedFAQ={expandedFAQ}
            toggleFAQ={toggleFAQ}
          />
        );

      case "gamePass":
        return (
          <div className={styles.heroLayout}>
            <div className={styles.heroImage}>
              <Image
                src={lifeidesignsvg}
                width={400}
                height={400}
                alt="Life i Design Game"
                className={styles.heroImageContent}
              />
            </div>

            <div className={styles.heroContent}>
              <div className={styles.heroText}>
                <div className={styles.pallaxGamePassSection}>
                  <h3 className={styles.pallaxGamePassTitle}>Game Pass - This Is Your Move</h3>

                  <div className={styles.pallaxGamePassContent}>
                    <p className={styles.pallaxGamePassDescription}>
                      If the only thing stopping you from being you ‚Äî is you, The LIFEIDESIGN is for you.<br />
                      This is the moment you meet yourself halfway.<br />
                      If you&apos;re ready to stop rehearsing,<br />
                      This is your cue.<br />
                      This is your move.
                    </p>
                  </div>

                  <div className={styles.pallaxGamePassCta}>
                    <div className={styles.pallaxCtaSection}>
                      <div className={styles.pallaxCtaAction}>
                        <h4 className={styles.pallaxActionTitle}>Vibe Check ‚Üí Win Your Game Pass.</h4>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );

      case "contact":
        return (
          <div className={styles.heroLayout}>
            <div className={styles.heroContent}>
              <div className={styles.heroText}>
                <div className={styles.pallaxContactSection}>
                  <h3 className={styles.pallaxContactTitle}>Get In Touch</h3>

                  <div style={{ display: 'flex', justifyContent: 'center', margin: '20px 0' }}>
                    <Image
                      src={lifeidesignsvg}
                      width={120}
                      height={120}
                      alt="Life i Design Game"
                      className={styles.heroImageContent}
                      style={{ width: '200px', height: '200px' }}
                    />
                  </div>

                  <div className={styles.pallaxContactContent}>
                    <p className={styles.pallaxContactDescription}>
                      If you&apos;re a reviewer, interested in testing our games, have press inquiries, want to collaborate, or just have a question, reach out to us: <a href="mailto:yo@lifeidesign.games" className={styles.pallaxEmailLink}>yo@lifeidesign.games</a>
                    </p>
                  </div>
                </div>
              </div>
            </div>

            <div className={styles.separatorLine}></div>

            <div className={styles.heroContent}>
              <div className={styles.heroText}>
                <div className={styles.pallaxContactSection}>
                  <h3 className={styles.pallaxContactTitle}>Press Kit</h3>

                  <div style={{ display: 'flex', justifyContent: 'center', margin: '20px 0' }}>
                    <Image
                      src={lifeidesignsvg}
                      width={120}
                      height={120}
                      alt="Life i Design Game"
                      className={styles.heroImageContent}
                      style={{ width: '200px', height: '200px' }}
                    />
                  </div>

                  <div className={styles.pallaxContactContent}>
                    <p className={styles.pallaxContactDescription}>
                      If you&apos;re a reviewer, interested in our games, need press materials, want to collaborate, or just have a question, download our press kit:<a href="mailto:yo@lifeidesign.games" className={styles.pallaxEmailLink}>Click Here</a>
                    </p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );

      default:
        return null;
    }
  };

  return (
    <div className={styles.container}>
      {/* Fixed Text Container */}
      <div className={styles.fixedTextContainer}>
        {/* Fixed Flipping Words */}
        <div className={styles.fixedFlippingWords}>
          <SlideFlippingWords currentWord={slideWords[currentSection]} size={32} mute={isMuted} />
        </div>

        {/* Fixed Dummy Text */}
        <div className={styles.fixedDummyText}>
          {dummyTexts[currentSection]}
        </div>
      </div>

      {/* Fixed Small Cube Grid at Top Right */}
      <div className={styles.fixedSmallCubeGrid}>
        <div
          className={styles.smallRubiksCube}
          onClick={() => setSelectedMember((prev) => (prev + 1) % 9)}
          onMouseEnter={() => setIsHoveringCube(true)}
          onMouseLeave={() => setIsHoveringCube(false)}
        >
          <div className={styles.smallCubeRow}>
            <div
              className={`${styles.smallCubeSquare} ${selectedMember === 0 ? styles.active : ''}`}
            ></div>
            <div
              className={`${styles.smallCubeSquare} ${selectedMember === 1 ? styles.active : ''}`}
            ></div>
            <div
              className={`${styles.smallCubeSquare} ${selectedMember === 2 ? styles.active : ''}`}
            ></div>
          </div>
          <div className={styles.smallCubeRow}>
            <div
              className={`${styles.smallCubeSquare} ${selectedMember === 3 ? styles.active : ''}`}
            ></div>
            <div
              className={`${styles.smallCubeSquare} ${selectedMember === 4 ? styles.active : ''}`}
            ></div>
            <div
              className={`${styles.smallCubeSquare} ${selectedMember === 5 ? styles.active : ''}`}
            ></div>
          </div>
          <div className={styles.smallCubeRow}>
            <div
              className={`${styles.smallCubeSquare} ${selectedMember === 6 ? styles.active : ''}`}
            ></div>
            <div
              className={`${styles.smallCubeSquare} ${selectedMember === 7 ? styles.active : ''}`}
            ></div>
            <div
              className={`${styles.smallCubeSquare} ${selectedMember === 8 ? styles.active : ''}`}
            ></div>
          </div>
        </div>

        {/* Popup Container */}
        <div className={`${styles.cubePopup} ${isHoveringCube ? styles.show : ''}`}>
          <div className={styles.popupOption}>Option 1</div>
          <div className={styles.popupOption}>Option 2</div>
          <div className={styles.popupOption}>Option 3</div>
        </div>
      </div>

      {sections.map((section, index) => (
        <section
          key={index}
          ref={el => sectionsRef.current[index] = el}
          className={`${styles.section} ${styles[section.className]}`}
        >
          <div
            ref={el => outerWrappersRef.current[index] = el}
            className={styles.outer}
          >
            <div
              ref={el => innerWrappersRef.current[index] = el}
              className={styles.inner}
            >
              <div
                ref={el => imagesRef.current[index] = el}
                className={styles.bg}
              >
                {renderSectionContent(section, index)}
              </div>
            </div>
          </div>
        </section>
      ))}

      {/* Progress Indicator */}
      <div
        className={styles.progressIndicator}
        onMouseEnter={() => {
          setIsHoveringProgress(true);
          // Clear any existing timeout
          if (progressTimeoutRef.current) {
            clearTimeout(progressTimeoutRef.current);
            progressTimeoutRef.current = null;
          }
        }}
        onMouseLeave={() => {
          // Set timeout to hide after 5 seconds
          progressTimeoutRef.current = setTimeout(() => {
            setIsHoveringProgress(false);
          }, 5000);
        }}
      >
        {/* Mute/Unmute Button */}
        <div className={`${styles.muteButtonContainer} ${isHoveringProgress ? styles.show : ''}`}>
          <button
            className={styles.muteButton}
            onClick={toggleMute}
            title={isMuted ? "Unmute" : "Mute"}
          >
            {isMuted ? (
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className="size-6">
                <path strokeLinecap="round" strokeLinejoin="round" d="M17.25 9.75 19.5 12m0 0 2.25 2.25M19.5 12l2.25-2.25M19.5 12l-2.25 2.25m-10.5-6 4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.009 9.009 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" />
              </svg>
            ) : (
              <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className="size-6">
                <path strokeLinecap="round" strokeLinejoin="round" d="M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.009 9.009 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" />
              </svg>
            )}
          </button>
        </div>

        <div className={styles.progressBar}>
          {Array.from({ length: sections.length }, (_, index) => (
            <div
              key={index}
              className={`${styles.progressDot} ${currentSection === index ? styles.active : ''}`}
              onClick={() => scrollToSection(index)}
            />
          ))}
        </div>
      </div>

      <FloatingArrow
        currentSection={currentSection}
        onNextSlide={scrollToSection}
        isVisible={false}
      />

      <VibeCheckButton
        currentSection={currentSection}
        onNextSlide={scrollToSection}
      />
    </div>
  );
};

export default PallaxPage;